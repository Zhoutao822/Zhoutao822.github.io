<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://zhoutao822.coding.me').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="参考：  RxJava2 EventBus Android Handler 消息机制详述 Android 多线程：手把手教你使用AsyncTask EventBus使用详解 Rxjava这一篇就够了，墙裂推荐 精彩的RxJava源码剖析 给 Android 开发者的 RxJava 详解  Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时">
<meta property="og:type" content="article">
<meta property="og:title" content="Android框架-RxJava">
<meta property="og:url" content="http://zhoutao822.coding.me/archives/686da54d.html">
<meta property="og:site_name" content="Tao">
<meta property="og:description" content="参考：  RxJava2 EventBus Android Handler 消息机制详述 Android 多线程：手把手教你使用AsyncTask EventBus使用详解 Rxjava这一篇就够了，墙裂推荐 精彩的RxJava源码剖析 给 Android 开发者的 RxJava 详解  Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-25T12:32:26.000Z">
<meta property="article:modified_time" content="2020-01-17T15:07:46.314Z">
<meta property="article:author" content="Tao Zhou">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Handler">
<meta property="article:tag" content="AsyncTask">
<meta property="article:tag" content="EventBus">
<meta property="article:tag" content="RxJava">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhoutao822.coding.me/archives/686da54d.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Android框架-RxJava | Tao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zhoutao822.coding.me/archives/686da54d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Tao Zhou">
      <meta itemprop="description" content="学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tao">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android框架-RxJava
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-25 20:32:26" itemprop="dateCreated datePublished" datetime="2019-07-25T20:32:26+08:00">2019-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-17 23:07:46" itemprop="dateModified" datetime="2020-01-17T23:07:46+08:00">2020-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          
            <span id="/archives/686da54d.html" class="post-meta-item leancloud_visitors" data-flag-title="Android框架-RxJava" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/686da54d.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/686da54d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>57k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>52 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>参考：</p>
<blockquote>
<p><a href="https://github.com/ReactiveX/RxJava/tree/2.x" target="_blank" rel="noopener">RxJava2</a><br />
<a href="http://greenrobot.org/eventbus/" target="_blank" rel="noopener">EventBus</a><br />
<a href="https://www.jianshu.com/p/1a5a3db45cfa" target="_blank" rel="noopener">Android Handler 消息机制详述</a><br />
<a href="https://www.jianshu.com/p/ee1342fcf5e7" target="_blank" rel="noopener">Android 多线程：手把手教你使用AsyncTask</a><br />
<a href="https://juejin.im/post/5a6c36fff265da3e2f012f82" target="_blank" rel="noopener">EventBus使用详解</a><br />
<a href="https://juejin.im/post/5a224cc76fb9a04527256683" target="_blank" rel="noopener">Rxjava这一篇就够了，墙裂推荐</a><br />
<a href="http://www.10tiao.com/html/227/201802/2650242399/1.html" target="_blank" rel="noopener">精彩的RxJava源码剖析</a><br />
<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p>
</blockquote>
<p>Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。</p>
<a id="more"></a>
<h2 id="1-handler"><a class="markdownIt-Anchor" href="#1-handler"></a> 1. Handler</h2>
<p>Handler是Android中最简单的线程间通信方式，同时也可以在同一个线程中发送消息，但是使用时需要注意内存泄漏的问题。</p>
<h3 id="11-handler简单使用"><a class="markdownIt-Anchor" href="#11-handler简单使用"></a> 1.1 Handler简单使用</h3>
<p>还是以和风天气请求为例，我们的目标是在子线程中请求数据，然后通过Handler将数据传到主线程中并显示出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String KEY = <span class="string">"XXXXXXXXXX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URL = <span class="string">"https://free-api.heweather.net/s6/weather/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        <span class="comment">// Handler的实例化，重写handleMessage方法用于等待处理msg，</span></span><br><span class="line">        <span class="comment">// handleMessage方法是回调，在回调中更新UI，此时执行在主线程，</span></span><br><span class="line">        <span class="comment">// 在Android Studio中会提示这里存在内存泄漏问题</span></span><br><span class="line">        handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                textView.setText(msg.obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 在子线程开启一个网络请求</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Retrofit通用代码</span></span><br><span class="line">                Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                        .baseUrl(URL) <span class="comment">// 设置网络请求的公共Url地址</span></span><br><span class="line">                        .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Call&lt;WeatherEntity&gt; call = api.getNowWeather(<span class="string">"beijing"</span>, KEY);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 为了在当前子线程获取数据，这里直接使用execute</span></span><br><span class="line">                    WeatherEntity result = call.execute().body();</span><br><span class="line">                    <span class="comment">// Message的实例化方法Message.obtain</span></span><br><span class="line">                    Message message = Message.obtain();</span><br><span class="line">                    <span class="comment">// 可以通过Message附加很多数据，这里仅用obj，保存我们网络请求得到的实例</span></span><br><span class="line">                    message.obj = result;</span><br><span class="line">                    <span class="comment">// 通过handler.sendMessage(message)实现调用回调方法，完成数据传输</span></span><br><span class="line">                    <span class="comment">// 这种操作有点类似于接口回调</span></span><br><span class="line">                    handler.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的内存泄露的原因可以参考其他资料，主要是<strong>Java 中非静态内部类和匿名内部类会持有外部类的引用</strong>同时<strong>Handler 的生命周期比外部类长</strong>导致的。如何解决，肯定就是让Handler是静态内部类就完事了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String KEY = <span class="string">"XXXXXXXXXX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URL = <span class="string">"https://free-api.heweather.net/s6/weather/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        <span class="comment">// 使用自定义的静态内部类</span></span><br><span class="line">        handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 子线程请求没有变化</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                        .baseUrl(URL) <span class="comment">// 设置网络请求的公共Url地址</span></span><br><span class="line">                        .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Call&lt;WeatherEntity&gt; call = api.getNowWeather(<span class="string">"beijing"</span>, KEY);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    WeatherEntity result = call.execute().body();</span><br><span class="line">                    Message message = Message.obtain();</span><br><span class="line">                    message.obj = result;</span><br><span class="line">                    handler.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        textView.setText(msg.obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义静态内部类，与onDestroy中removeCallbacksAndMessages一起使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;MainActivity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 同时需要持有对MainActivity的弱引用</span></span><br><span class="line">            <span class="keyword">this</span>.reference = <span class="keyword">new</span> WeakReference&lt;&gt;(mainActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            MainActivity mainActivity = reference.get();</span><br><span class="line">            <span class="keyword">if</span> (mainActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将msg传给MainActivity处理</span></span><br><span class="line">                mainActivity.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-handler线程间通信"><a class="markdownIt-Anchor" href="#12-handler线程间通信"></a> 1.2 Handler线程间通信</h3>
<p>上面的例子仅演示了从子线程传数据给主线程，那么如果同时需要从主线程传数据给子线程，怎么办</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先需要自定义MyThread，完成Looper的初始化，否则子线程不会自动初始化Looper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Looper looper;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            looper = Looper.myLooper();</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在onCreate方法中</span></span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, String.valueOf(Thread.currentThread()));</span><br><span class="line">    MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start(); <span class="comment">// 必须先启动子线程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 确保子线程中的Looper初始化完成</span></span><br><span class="line">        <span class="keyword">if</span> (thread.looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时handler的handleMessage方法是在子线程MyThread中执行的</span></span><br><span class="line">            <span class="comment">// 两处log中线程的值是不一样的，通过Handler的构造方法实现子线程的调用</span></span><br><span class="line">            handler = <span class="keyword">new</span> Handler(thread.looper) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, String.valueOf(msg.what) + Thread.currentThread());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            handler.sendEmptyMessage(<span class="number">12321</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用定义好的HandlerThread，则不需要继承Thread，直接使用，</span></span><br><span class="line"><span class="comment">// HandlerThread默认帮我们完成了Looper的初始化</span></span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, String.valueOf(Thread.currentThread()));</span><br><span class="line">    <span class="comment">// HandlerThread需要用String的构造方法，我们在log中也可以看到</span></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"new thread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.getLooper() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> Handler(thread.getLooper()) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, String.valueOf(msg.what) + Thread.currentThread());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            handler.sendEmptyMessage(<span class="number">12321</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么子线程需要初始化Looper，而主线程不需要？</p>
</blockquote>
<p>首先需要明白的是，只有需要处理消息的线程才需要Looper，即哪个线程执行了handleMessage方法，则线程需要Looper，原因在源码分析中解释；主线程以及HandlerThread会自动进行Looper的初始化，而<code>new Thread()</code>不会，因此在第二个例子中，子线程需要处理消息，所以需要初始化Looper而第一个例子中主线程不需要。</p>
<blockquote>
<p>Handler的初始化，其构造方法依赖于什么，为什么第二个例子中Handler不是在主线程中初始化的吗？</p>
</blockquote>
<p>首先需要知道的是Handler是可以被跨线程调用的，而View是不可以的，举个例子，如果在第一个例子中我们在子线程中调用<code>textView.setText(result.toString());</code>，则会报错<code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code>，而Handler没问题，Handler默认构造方法<code>new Handler()</code>会将当前线程的Looper保存在自己这个实例中，即将主线程中的Looper保存，而带参数的构造方法<code>new Handler(thread.looper)</code>会保存thread的looper在实例中，又因为Handler是可以跨线程调用的，所以区分Handler属于哪个线程其实是根据构造方法传入的参数决定的，至于Handler归属于不同的线程会有什么影响，在源码分析中解释。</p>
<h3 id="13-handler源码分析"><a class="markdownIt-Anchor" href="#13-handler源码分析"></a> 1.3 Handler源码分析</h3>
<p>以从子线程向主线程发送消息为例，首先从ActivityThread的main方法开始，前面说过主线程中的Looper是自动初始化的，其初始化的位置就在ActivityThread的main方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java 核心就两个Looper.prepareMainLooper()和Looper.loop()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 显然这里是不会执行的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再看看Looper.prepareMainLooper()的作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Looper.java 看注释就知道是是为主线程初始化Looper，关键还是看prepare方法，再看myLooper</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare方法通过sThreadLocal set了一个Looper实例，</span></span><br><span class="line"><span class="comment">// 一个Looper实例保存了MessageQueue和Thread.currentThread()</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myLooper方法从sThreadLocal get到Looper，那正好对应上面prepare set的Looper，</span></span><br><span class="line"><span class="comment">// ThreadLocal的作用是可以保存线程内的变量，简而言之就是通过ThreadLocal的set和get方法</span></span><br><span class="line"><span class="comment">// 处理的变量仅属于某个线程，以Looper为例，在某个线程中有且仅有一个</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment">     * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后调用了Looper.loop()</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Looper.loop()会进入一个死循环，但是这个循环并不会导致卡死，</span></span><br><span class="line">        <span class="comment">// 涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，</span></span><br><span class="line">        <span class="comment">// 便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，</span></span><br><span class="line">        <span class="comment">// 直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。</span></span><br><span class="line">        <span class="comment">// 这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，</span></span><br><span class="line">        <span class="comment">// 当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。</span></span><br><span class="line">        <span class="comment">//  所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</span></span><br><span class="line">        <span class="comment">// 先拿到当前线程的Looper，然后拿到Looper中的MessageQueue</span></span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 开启循环，Android中主线程上所有的点击事件、UI绘制都是通过Message发送到MessageQueue中等待执行</span></span><br><span class="line">        <span class="comment">// 所以这里必须是死循环，因为如果跳出了这个循环说明已经无法再继续处理任何Message，那么随之而来的肯定就是</span></span><br><span class="line">        <span class="comment">// 应用崩溃或者重启Looper，但是这里的循环并不会导致卡死，理由在上面已经简要说明了</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 循环的作用就是通过queue.next()不断地从MessageQueue取出Message，next方法中也是一个死循环，</span></span><br><span class="line">            <span class="comment">// 正常情况下queue.next()应该返回一个有效的Message，或者休眠不返回任何值，如果返回null，</span></span><br><span class="line">            <span class="comment">// 说明出了问题</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当取出的message为空时说明MessageQueue被终止了，因此跳出循环，执行其他操作，比如重启Looper或者崩溃？</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 当我们取到有效的Message后，就需要知道这个Message应该由谁来处理，即Target，从Message源码中可知，</span></span><br><span class="line">            <span class="comment">// 这个Target实际上就是Handler，最终调用的就是Handler的dispatchMessage方法，从这里我们就知道了</span></span><br><span class="line">            <span class="comment">// 只要其他线程能够将Message发送到主线程的MessageQueue中，那么这个Message就可以被主线程的Handler处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 最后需要对Message对象进行回收</span></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityThread的main方法中对主线程的Looper进行初始化，同样的主线程的MessageQueue也准备好对其中的Message进行分发，这都是通过死循环实现的，相当于MessageQueue是一个等待队列，有消息来了，他就取消息并调用Message对应的Handler的dispatchMessage方法，如果没有就休眠，然后我们看看Handler的初始化以及Message的发送是如何实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler.java Handler的构造方法分为两类，一类是参数带Looper的，另一类是不带Looper</span></span><br><span class="line"><span class="comment">// 不带Looper的构造函数最终会调用到最后一个构造函数，并进行Looper的初始化；</span></span><br><span class="line"><span class="comment">// 带Looper的构造函数会直接保存参数中的Looper实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Looper的myLooper方法会初始化当前线程的Looper</span></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用<code>handler.sendMessage(message);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler.java sendMessage方法会直接调用sendMessageDelayed</span></span><br><span class="line"><span class="comment">// sendMessageDelayed就是多个延时的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过加上SystemClock.uptimeMillis()可以直接得到执行的具体时间</span></span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终还是使用Handler的MessageQueue</span></span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里将Message的target设置为当前handler</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后调用MessageQueue的enqueueMessage方法</span></span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageQueue.java enqueueMessage将Message加入链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果MessageQueue被终止了，那么Message还需要回收</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 根据msg.next基本可以发现Message是一个链表中的节点，也就是说MessageQueue中的mMessages</span></span><br><span class="line">            <span class="comment">// 是一种链表形式的结构，其中mMessages是表头，当执行next方法时就会将表头也就是mMessages表示的</span></span><br><span class="line">            <span class="comment">// Message返回，当我们传入的Message满足以下任意条件时，可以将此Message作为表头：</span></span><br><span class="line">            <span class="comment">// 1. 表头本身为空，很明显当没有任何Message传入的时候；</span></span><br><span class="line">            <span class="comment">// 2. 当我们传入的Message没有任何延迟，这也很显然，立即执行的Message当然要放第一个；</span></span><br><span class="line">            <span class="comment">// 3. 当我们传入的Message的执行时间在表头的执行时间之前，这也很显然，按照时间排序。</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果Message不是表头位置，那么肯定就是链表中的某个位置</span></span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="comment">// 链表的遍历，还要判断时间when</span></span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这就很简单了，有序链表中加入某个节点，排序方式为when的值</span></span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们就知道了Message被Handler加到了Handler线程的MessageQueue中，而Handler线程中的Looper一直在等待Message进入MessageQueue，通过queue.next()取出Message，然后调用Handler的dispatchMessage方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dispatchMessage处理Message的方式也很简单</span></span><br><span class="line">    <span class="comment">// 首先判断Message是否设置了Callback，如果有</span></span><br><span class="line">    <span class="comment">// 则执行message.callback.run()</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有，则判断Handler是否初始化设置了Callback，</span></span><br><span class="line">        <span class="comment">// 这个和Handler的构造函数相关</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就执行handler重写的handleMessage方法，</span></span><br><span class="line">        <span class="comment">// 这个方法是在我们继承Handler时重写的，或者</span></span><br><span class="line">        <span class="comment">// 在使用Handler匿名内部类时重写的</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是完整的通过Handler从子线程发送消息到主线程并执行的过程，也解决了我的一些问题：</p>
<blockquote>
<p>1.为什么要设计Handler来传输消息？</p>
</blockquote>
<p>因为多线程的情况下并不确定子线程何时能够执行完毕获取数据，所以需要设计Handler实现一种回调机制，即当子线程数据获取完成后将数据传到主线程中，通过主线程中的回调决定如何处理传来的数据。</p>
<blockquote>
<p>2.为什么要用MessageQueue和Looper这种工具？</p>
</blockquote>
<p>我想是因为既然子线程并不确定何时结束，其次如果存在多个子线程向主线程传递消息，那干脆将这些消息都放在一个队列MessageQueue中，因为多个子线程之间的执行顺序我们也无法确定，如果放在队列中，那么根据消息附加的时间来进行排序我们就可以按照顺序读取从各个子线程发送过来的消息了，与此同时，需要一个能够不停地读取队列中消息的工具Looper，Looper可以循环取数据但是不会阻塞卡死。</p>
<h3 id="14-handler进阶"><a class="markdownIt-Anchor" href="#14-handler进阶"></a> 1.4 Handler进阶</h3>
<p>Handler除了可以发送Message外，还可以post Runnable，Runnable是接口，提供run方法，Thread类实现了Runnable接口，所以Thread需要实现run方法，run方法中的内容就是执行在Thread线程中，如果Runnable是通过Handler post，那么根据Message的原理，应该明白此Runnable就是运行在Handler归属的线程中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    <span class="comment">// handler不重写handleMessage方法</span></span><br><span class="line">    handler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Retrofit通用代码</span></span><br><span class="line">            Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                    .baseUrl(URL) <span class="comment">// 设置网络请求的公共Url地址</span></span><br><span class="line">                    .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Call&lt;WeatherEntity&gt; call = api.getNowWeather(<span class="string">"beijing"</span>, KEY);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 为了在当前子线程获取数据，这里直接使用execute</span></span><br><span class="line">                <span class="keyword">final</span> WeatherEntity result = call.execute().body();</span><br><span class="line">                <span class="comment">// 通过post直接修改textView的text</span></span><br><span class="line">                handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        textView.setText(result.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为textView只能在主线程进行设置，所以很显然handler post的Runnable是在主线程运行的，这样就不需要传递数据，而是直接处理数据了，下面看看Runnable是如何被处理的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// sendMessageDelayed之前分析过，这里是将Runnable放入Message中了</span></span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Message保存了这个Runnable，保存在callback，这个之前在dispatchMessage中见过</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 之前sendMessage都是走的第二个判断，post走的就是第一个判断，</span></span><br><span class="line">        <span class="comment">// 我们的Runnable现在不为空</span></span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 结果很明显了，就是执行了Runnable的run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面演示一下多个线程向主线程发送消息会产生怎样的结果，自定义线程MessageThread用于发送Message，普通的Thread用于post Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    <span class="comment">// handler根据传过来的Message的what值进行不同的操作</span></span><br><span class="line">    handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, <span class="string">"Thread 0: "</span> + msg.obj.toString());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, <span class="string">"Thread 1: "</span> + msg.obj.toString());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, <span class="string">"Thread 2: "</span> + msg.obj.toString());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 开启三个线程发送Message，加上延时</span></span><br><span class="line">    <span class="keyword">new</span> MessageThread(<span class="number">0</span>, <span class="string">"thread 0 hahaha"</span>, <span class="number">3000</span>).start();</span><br><span class="line">    <span class="keyword">new</span> MessageThread(<span class="number">1</span>, <span class="string">"thread 1 oooooo"</span>, <span class="number">1000</span>).start();</span><br><span class="line">    <span class="keyword">new</span> MessageThread(<span class="number">2</span>, <span class="string">"thread 2 yyyyyy"</span>, <span class="number">2000</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post Runnable也加上延时，注意这里的postDelayed并不会阻塞主线程，</span></span><br><span class="line">    <span class="comment">// 原理同Looper.loop()，所以不会引起ANR，这个延时只会影响此Message在MessageQueue</span></span><br><span class="line">    <span class="comment">// 中的位置</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Log.i(<span class="string">"aaaa"</span>, <span class="string">"MainThread"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> delay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageThread</span><span class="params">(<span class="keyword">int</span> what, String text, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.what = what;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = what;</span><br><span class="line">        message.obj = text;</span><br><span class="line">        handler.sendMessageDelayed(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: thread 1 oooooo</span><br><span class="line">Thread 2: thread 2 yyyyyy</span><br><span class="line">Thread 0: thread 0 hahaha</span><br><span class="line">MainThread</span><br></pre></td></tr></table></figure>
<h2 id="2-asynctask"><a class="markdownIt-Anchor" href="#2-asynctask"></a> 2. AsyncTask</h2>
<p>通过Handler实现的多线程通信在使用上还是有很多不方便的地方，比如需要显示的创建子线程，每次创建子线程都是对资源的消耗，当然也可以使用线程池来减少线程资源的创建与销毁，同时需要定义Handler的处理方式，对于每一个需要处理消息的线程都需要定义其Handler，这样就显得比较乱，因此可以使用AsyncTask来替代，先看一下如何使用。</p>
<h3 id="21-asynctask简单使用"><a class="markdownIt-Anchor" href="#21-asynctask简单使用"></a> 2.1 AsyncTask简单使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依然以请求和风天气数据为例，现在我们为加载数据时显示进度，为什么要显示进度呢</span></span><br><span class="line"><span class="comment">// 从设计理念来看，当我们给某些需要长时间等待的操作加上进度条时，用户对这个操作的</span></span><br><span class="line"><span class="comment">// 容忍度会增加，比如常见的进入游戏的界面，会显示进度条，这样的话就算耗时相对较长，</span></span><br><span class="line"><span class="comment">// 但是用户可以根据进度有一个心理预期，从而提升容忍度；如果你的耗时操作没有任何进度</span></span><br><span class="line"><span class="comment">// 提示，那么用户很容易觉得你的应用是不是卡死了，从而降低了体验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">"XXXXXXXXXXXX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"https://free-api.heweather.net/s6/weather/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="comment">// execute的参数等价于doInBackground的参数</span></span><br><span class="line">        task.execute(<span class="string">"beijing"</span>, <span class="number">50L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// AsyncTask是抽象类，需要自定义Task并实现doInBackground方法，除了doInBackground之外</span></span><br><span class="line"><span class="comment">// 还有几个方法用于初始化、显示进度、输出结果等功能，三个参数Object, Integer, WeatherEntity为泛型参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Object</span>, <span class="title">Integer</span>, <span class="title">WeatherEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onPreExecute在主线程执行，用于做一些提前的初始化</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            textView.setText(<span class="string">"Start!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// doInBackground在子线程执行，不需要显示地创建Thread，这里的参数params</span></span><br><span class="line">        <span class="comment">// 是一个泛型参数，也就是说可以传入多个参数，相当于参数数组，参数的传入是</span></span><br><span class="line">        <span class="comment">// task.execute传入，返回值由AsyncTask第三个泛型参数决定，同时也是</span></span><br><span class="line">        <span class="comment">// onPostExecute的输入参数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> WeatherEntity <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据传入的顺序读取，location就是beijing，delay就是50L，</span></span><br><span class="line">            <span class="comment">// 为了模拟进度，这里传入一个延时，正式使用时需要根据数据实际传输的进度</span></span><br><span class="line">            <span class="comment">// 展示进度</span></span><br><span class="line">            String location = (String) params[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> delay = (<span class="keyword">long</span>) params[<span class="number">1</span>];</span><br><span class="line">            WeatherEntity result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 先获取数据，我们知道这里取数据的速度其实是很快的</span></span><br><span class="line">                result = getData(location);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后显示进度，这里仅模拟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (count &lt; <span class="number">99</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    count += length;</span><br><span class="line">                    <span class="comment">// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）</span></span><br><span class="line">                    publishProgress(count);</span><br><span class="line">                    <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                    Thread.sleep(delay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后返回取到的数据</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onProgressUpdate在主线程执行，显示进度</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">            textView.setText(String.format(Locale.CHINA, <span class="string">"加载进度：%d%%"</span>, values[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onPostExecute在主线程执行，用于处理doInBackground返回的数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(WeatherEntity weatherEntity)</span> </span>&#123;</span><br><span class="line">            textView.setText(weatherEntity.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AsyncTask可以通过调用isCancelled主动终止</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            textView.setText(<span class="string">"Cancel!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> WeatherEntity <span class="title">getData</span><span class="params">(String location)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                    .baseUrl(URL)</span><br><span class="line">                    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                    .build();</span><br><span class="line">            Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Call&lt;WeatherEntity&gt; call = api.getNowWeather(location, KEY);</span><br><span class="line">            <span class="keyword">return</span> call.execute().body();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-asynctask源码分析"><a class="markdownIt-Anchor" href="#22-asynctask源码分析"></a> 2.2 AsyncTask源码分析</h3>
<p>首先从task.execute开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AsyncTask.java</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// executeOnExecutor传入两个参数sDefaultExecutor和params，</span></span><br><span class="line">        <span class="comment">// sDefaultExecutor看名字就知道是一个Executor，Executor提供execute方法，</span></span><br><span class="line">        <span class="comment">// 用于消耗Runnable，我们先看看sDefaultExecutor是什么</span></span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sDefaultExecutor实际上是new SerialExecutor()，static修饰加上</span></span><br><span class="line">    <span class="comment">// synchronized修饰execute方法，保证多个Task启动execute时是按照顺序执行的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SerialExecutor提供一个队列mTasks用于保存Runnable</span></span><br><span class="line">        <span class="comment">// mActive表示当前需要执行的Runnable</span></span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line">        <span class="comment">// execute方法把传入的Runnable加入到队列中，但是不是直接加入的，</span></span><br><span class="line">        <span class="comment">// 而是通过new Runnable改造了，让其在执行了run之后会执行scheduleNext</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// scheduleNext从mTasks的对头取Runnable，通过THREAD_POOL_EXECUTOR</span></span><br><span class="line">        <span class="comment">// 执行Runnable，联系SerialExecutor的execute方法，就知道了一旦调用了</span></span><br><span class="line">        <span class="comment">// SerialExecutor的execute方法，就会不断从mTasks取任务，然后交给线程池</span></span><br><span class="line">        <span class="comment">// THREAD_POOL_EXECUTOR去执行，至于线程池是如何execute暂时不解释，</span></span><br><span class="line">        <span class="comment">// 只需要知道线程池会分配空闲的线程并执行传入的mFuture的run方法即可</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// THREAD_POOL_EXECUTOR就是传说中的线程池，THREAD_POOL_EXECUTOR.execute</span></span><br><span class="line">    <span class="comment">// 会自动使用线程池中空闲的线程完成mActive的任务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                sPoolWorkQueue, sThreadFactory);</span><br><span class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明白了sDefaultExecutor本质上是线程池，接下来看executeOnExecutor怎么调用线程池</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">            Params... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先设置了状态为RUNNING</span></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是不是很熟悉，我们继承AsyncTask时重写的onPreExecute方法</span></span><br><span class="line">        onPreExecute();</span><br><span class="line">        <span class="comment">// 然后将参数保存在mWorker.mParams</span></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        <span class="comment">// 调用exec.execute，这里的exec就是上面的SerialExecutor</span></span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时我们需要明白mWorker和mFuture是什么，这里就要了解子类继承父类时，构造方法的执行了</span></span><br><span class="line"><span class="comment">// 在我们MyTask task = new MyTask();时，其实完成了父类的无参构造方法的执行，也就是AsyncTask</span></span><br><span class="line"><span class="comment">// 的无参构造方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也就是说mWorker和mFuture在new MyTask()时已经完成了初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// callbackLooper为null，所以mHandler为getMainHandler方法的返回值，</span></span><br><span class="line">        <span class="comment">// 看名字就知道返回的是主线程的Handler，但是这个Handler有点东西</span></span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mWorker提供了一个对象WorkerRunnable，WorkerRunnable实现了Callable接口的call方法</span></span><br><span class="line">        <span class="comment">// 当mWorker的call方法被执行时，我们就可以得到结果</span></span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                Result result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">//noinspection unchecked</span></span><br><span class="line">                    <span class="comment">// 很熟悉的doInBackground方法，传入的参数为mWorker的mParams，即我们</span></span><br><span class="line">                    <span class="comment">// 在task.execute("beijing", 50L);传入的参数</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// mFuture以mWorker为参数实现了FutureTask，这里的FutureTask可以被SerialExecutor execute，</span></span><br><span class="line">        <span class="comment">// 会调用FutureTask的run方法，run方法中会执行mWorker的call方法，最终会调用FutureTask的done方法</span></span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// get方法得到的是FutureTask执行run方法后得到的result</span></span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postResultIfNotInvoked会进一步处理结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        <span class="keyword">if</span> (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postResult通过主线程的Handler发送了数据result，并标记MESSAGE_POST_RESULT</span></span><br><span class="line">    <span class="comment">// 表示数据已经获取完毕，应该交给主线程处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是记得上文介绍的Handler吗，它还有额外的功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在处理Message时，还可以判断并选择执行onProgressUpdate</span></span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="comment">// 上面说的数据获取完毕会标记MESSAGE_POST_RESULT</span></span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                    <span class="comment">// There is only one result</span></span><br><span class="line">                    <span class="comment">// 调用mTask，这里就是AsyncTask的finish方法</span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 熟悉的重写isCancelled和onPostExecute</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            <span class="comment">// 如果主动调用isCancelled则走onCancelled</span></span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 或者最终回到我们重写的onPostExecute</span></span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上就是正常的AsyncTask执行流程，但是别忘了我们有一个进度显示的功能</span></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            <span class="comment">// 通过Handler发送进度数据values</span></span><br><span class="line">            <span class="comment">// 这里就对应了上面的主线程的Handler的另一个功能，显示进度</span></span><br><span class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整理一下流程，很显然的是AsyncTask本质上还是基于Handler，但是在对线程的处理上采用了线程池，具体的执行过程：</p>
<ol>
<li>在<code>new MyTask()</code>时初始化了主线程的Handler和线程池，构造了FutureTask并提供了doInBackground的回调，并提供了通过sendToTarget的方式处理result和progress的方式；</li>
<li>当我们执行<code>task.execute(&quot;beijing&quot;, 50L);</code>的方法时，提供了onPreExecute的回调，并将参数传给第1步中的FutureTask，然后使用SerialExecutor execute第1步构造的的FutureTask，本质上还是线程池，只是附加了功能：连续处理队列中的所有任务；</li>
<li>最后将得到结果通过上面sendToTarget后Handler的回调handleMessage处理发送的数据</li>
</ol>
<p>仔细思考一下就会发现，AsyncTask提供了一个显示进度的方法，比较适用于上传下载文件的场景，因为下载进度与下载文件的大小是可知的，但是很多http框架比如Retrofit，可以很方便在接受Response的时候监听下载进度，导致AsyncTask无用武之处；同时对于登录注册功能来说，登录进度并不是很适合量化，所以也不适用；还有其他的场景我暂时也没有想到。这就导致了AsyncTask的作用被弱化了，除了集成doInBackground和onPostExecute方法就没有什么亮眼之处。</p>
<p>AsyncTask也提供了带Looper或者Handler参数的构造函数，此时会影响的只有postResult和publishProgress方法，即这两个方法会发送消息到Looper的线程中，但是子线程的Handler需要自定义handleMessage并自行判断msg.what，包括<code>MESSAGE_POST_RESULT</code>和<code>MESSAGE_POST_PROGRESS</code>，实现从子线程到子线程的消息传递。</p>
<h2 id="3-eventbus"><a class="markdownIt-Anchor" href="#3-eventbus"></a> 3. EventBus</h2>
<p>EventBus比上面介绍的两种方式更加强大，除了线程间通信之外，还可以在Activity间传递消息，同时兼具灵活的线程切换功能，先直接上一个简单的例子，依然是请求和风天气数据</p>
<blockquote>
<p>1.首先使用EventBus需要自定义MessageEvent，即通过EventBus传递的消息载体</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MessageEvent&#123;"</span> + <span class="string">"msg="</span> + msg + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.在需要处理消息的地方（Activity）中定义Subscribe方法，这个方法可以自动接收其他地方传来的消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe注解修饰处理MessageEvent的方法，有几个参数threadMode、sticky、priority</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">首先是threadMode：</span></span><br><span class="line"><span class="comment">POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。</span></span><br><span class="line"><span class="comment">如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，</span></span><br><span class="line"><span class="comment">如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后是sticky，sticky用于表示是否接收粘性事件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后是priority，priority决定不同的Subscribe方法接收事件的优先级，数值越大越早接收，</span></span><br><span class="line"><span class="comment">先接受的Subscribe方法还可以禁止事件继续传递下去</span></span><br><span class="line"><span class="comment">1. 只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值一致；</span></span><br><span class="line"><span class="comment">2. 只有当某个订阅方法的ThreadMode参数为POSTING的时候，它才能停止该事件的继续分发。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">// requestData方法用于处理发送的消息是String，其他则打印log</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestData</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(URL)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Call&lt;WeatherEntity&gt; call = api.getNowWeather(message.getMsg().toString(), KEY);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过EventBus把请求得到的天气发送出去</span></span><br><span class="line">            EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(call.execute().body()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> WeatherEntity) &#123;</span><br><span class="line">        Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.BACKGROUND: "</span> + message.getMsg().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// showMessage方法用于处理发送的消息是WeatherEntity，将其显示到TextView上，其他类型则打印log</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> WeatherEntity) &#123;</span><br><span class="line">        textView.setText(message.getMsg().toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.MAIN: "</span> + message.getMsg().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.在onStart和onStop中注册和取消注册</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 发送的消息本体是String，即请求的location</span></span><br><span class="line">            EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"beijing"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们点击textView的时候就会发送消息<code>new MessageEvent(&quot;beijing&quot;)</code>出去，如果打断点观察消息发送的流程就会清楚：</p>
<ol>
<li>我们在主线程发送的消息会首先由<code>ThreadMode.MAIN</code>的方法处理，此时就会打印log：</li>
<li>然后消息会发送到requestData方法，而requestData方法是<code>ThreadMode.BACKGROUND</code>，所以它会在子线程中执行，我们在子线程中又发了<code>new MessageEvent(call.execute().body())</code>，因此消息会首先由<code>ThreadMode.BACKGROUND</code>的方法处理，即requestData方法自身，此时打印log；</li>
<li>最后消息又传到了showMessage方法中，而showMessage方法是<code>ThreadMode.MAIN</code>，所以可以执行在主线程，因此textView被设置了text，整个消息传递流程结束。</li>
</ol>
<p>根据上面的例子基本可以了解了EventBus发送消息的机制，类似于广播，不同的threadMode参数决定这个方法的执行线程，而消息发送时会首先发到当前线程的方法中，如果在这个方法中消息没有被取消，则会继续广播到其他线程的方法中，具体顺序可以测试一下，直到没有可以处理此消息的方法，整个消息传播的流程就结束了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下列方法处理从主线程发送的MessageEvent，我们观察一下log的顺序</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastMessage1</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.MAIN: "</span> + message.getMsg().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastMessage2</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.BACKGROUND: "</span> + message.getMsg().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastMessage3</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.POSTING: "</span> + message.getMsg().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastMessage4</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.ASYNC: "</span> + message.getMsg().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次是MAIN -&gt; POSTING -&gt; BACKGROUND -&gt; ASYNC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 20:40:38.419 28604-28604&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.MAIN: beijing</span><br><span class="line">2019-07-28 20:40:38.420 28604-28604&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.POSTING: beijing</span><br><span class="line">2019-07-28 20:40:38.421 28604-28765&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.BACKGROUND: beijing</span><br><span class="line">2019-07-28 20:40:38.422 28604-28766&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.ASYNC: beijing</span><br></pre></td></tr></table></figure>
<p>在看一下从BACKGROUND子线程发送的MessageEvent，依次是BACKGROUND -&gt; POSTING -&gt; MAIN -&gt; ASYNC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 20:53:27.151 30433-30481&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.BACKGROUND: shanghai</span><br><span class="line">2019-07-28 20:53:27.151 30433-30481&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.POSTING: shanghai</span><br><span class="line">2019-07-28 20:53:27.152 30433-30433&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.MAIN: shanghai</span><br><span class="line">2019-07-28 20:53:27.152 30433-30482&#x2F;com.example.gsondemo I&#x2F;aaaa: ThreadMode.ASYNC: shanghai</span><br></pre></td></tr></table></figure>
<p>消息广播的规则应该是首先是发送到post所在的线程，然后是POSTING，然后是其他线程，最后是ASYNC，因此我们可以在POSTING方法中取消消息的广播，那么消息就会被中断。</p>
<ul>
<li>普通事件删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().cancelEventDelivery(event);</span><br></pre></td></tr></table></figure>
<ul>
<li>粘性事件删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定粘性事件删除  </span></span><br><span class="line">T stickyEvent = EventBus.getDefault().getStickyEvent(eventType);  </span><br><span class="line"><span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    EventBus.getDefault().removeStickyEvent(stickyEvent);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有粘性事件 </span></span><br><span class="line">EventBus.getDefault().removeAllStickyEvents();</span><br></pre></td></tr></table></figure>
<p>除了普通事件之外，EventBus还可以发送粘性事件，解释起来比较复杂，简而言之就是让消息“飞一会”，在我们主动注册时才处理消息，用代码来解释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码是类似的，只是这次不在onStart方法内注册，而是通过button点击注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    button = findViewById(R.id.button);</span><br><span class="line">    textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// postSticky替代post</span></span><br><span class="line">            EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"beijing"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            EventBus.getDefault().register(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加sticky = true</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestData</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(URL)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Call&lt;WeatherEntity&gt; call = api.getNowWeather(message.getMsg().toString(), KEY);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(call.execute().body()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> WeatherEntity) &#123;</span><br><span class="line">        Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.BACKGROUND: "</span> + message.getMsg().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加sticky = true</span></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> WeatherEntity) &#123;</span><br><span class="line">        textView.setText(message.getMsg().toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.getMsg() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        Log.i(<span class="string">"aaaa"</span>, <span class="string">"ThreadMode.MAIN: "</span> + message.getMsg().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的结果就是当我们点击textView时，事件就会发出，但是Subscribe方法没有接收，当且仅当我们点击了button时，事件才开始被接收，即我们让消息在运行时“飞了一会”，消息并不会丢失，当我们主动去注册时才开始处理，这就是粘性事件。</p>
<p>priority就不详细解释了，对于有相同threadMode的方法，priority值越大越先接收到消息。</p>
<p>EventBus源码解析暂时留个坑。</p>
<h2 id="4-rxjava"><a class="markdownIt-Anchor" href="#4-rxjava"></a> 4. RxJava</h2>
<p><code>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</code></p>
<p>RxJava也是一个可以用于处理线程间通信的工具，但是功能非常强大（不仅限于线程间通信），不仅可以用于Java Web项目也可以在Android项目中使用，RxJava的使用方式与上述各种工具或者框架不太一样，它是通过流式调用的形式使用的。目前有三个版本分别是Version 1.x、Version 2.x以及最新的Version 3.x，新版本加入新的特性比如背压、Java 8等等，这里仅演示RxJava2</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"io.reactivex.rxjava2:rxjava:2.2.8"</span> <span class="comment">// 必要rxjava2依赖</span></span><br><span class="line">implementation <span class="string">"io.reactivex.rxjava2:rxandroid:2.1.0"</span> <span class="comment">// 必要rxandrroid依赖，切线程时需要用到AndroidSchedulers.mainThread()</span></span><br></pre></td></tr></table></figure>
<h3 id="41-rxjava结合retrofit"><a class="markdownIt-Anchor" href="#41-rxjava结合retrofit"></a> 4.1 RxJava结合Retrofit</h3>
<p>还是以请求和风天气数据为例，这是Retrofit与RxJava的结合使用，RxJava使用的是观察者模式，这里就不详细解释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(URL)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Api api = retrofit.create(Api<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 这里的getNowWeather方法在Api.java中返回的是Observable</span></span><br><span class="line">api.getNowWeather(<span class="string">"beijing"</span>, KEY)</span><br><span class="line">        .subscribeOn(Schedulers.io()) <span class="comment">// subscribeOn参数为io线程，表明getNowWeather请求数据执行在io线程</span></span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// observeOn参数为主线程，表明请求结束传递的数据在主线程处理</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;WeatherEntity&gt;() &#123; <span class="comment">// subscribe定义上面observeOn进行的方法，RxJava2中以Consumer代理处理，一般来说有两个Consumer，一个用于处理请求成功的数据，另一个处理异常</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(WeatherEntity weatherEntity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                textView.setText(weatherEntity.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"aaaa"</span>, throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="42-rxjava源码分析"><a class="markdownIt-Anchor" href="#42-rxjava源码分析"></a> 4.2 RxJava源码分析</h3>
<p>虽然上面的代码只演示了RxJava的线程切换功能，但是实际上RxJava的功能非常强大，在处理大量数据的情况下能够更加简洁有效的代码完成，同时兼具数据变换的功能，这里三言两语很难表述清除，需要实战演练就能够明白，与此同时，基于RxJava我们也可以自定义更多的工具函数，以RxJava流式调用的方式来使用。</p>
<p><strong>Observable警告：RxJava提供的各种方法比如subscribeOn、observeOn以及doOnNext等都会创建新的Observable和Observer，Observable是数据的被观察者，它保存了我们需要的数据；Observer是数据的观察者，数据如何发送、在哪个线程处理、如何处理异常等都是通过Observer处理的，一般来说每一个自定义的Observable都有一个内部类Observer，只是这个Observer是给上一级的Observable调用</strong></p>
<p>首先我们需要知道<code>retrofit.create(Api.class)</code>创建了什么，这个在Retrofit框架分析中已经做过了，在这种情况下是通过RxJava2CallAdapterFactory的RxJava2CallAdapter调用adapt方法返回的Observable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RxJava2CallAdapter.java</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先是创建CallExecuteObservable</span></span><br><span class="line">    Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">        ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call)</span><br><span class="line">        : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line"></span><br><span class="line">    Observable&lt;?&gt; observable;</span><br><span class="line">    <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">      observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">      <span class="comment">// 然后根据参数，返回的是BodyObservable</span></span><br><span class="line">      observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      observable = responseObservable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">      observable = observable.subscribeOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">      <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(observable);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而BodyObservable继承自Observable，并且有一个内部类BodyObserver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BodyObservable.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;Response&lt;T&gt;&gt; upstream;</span><br><span class="line"></span><br><span class="line">  BodyObservable(Observable&lt;Response&lt;T&gt;&gt; upstream) &#123;</span><br><span class="line">    <span class="keyword">this</span>.upstream = upstream;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// subscribeActual方法会在Observable调用subscribe方法时被调用</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    upstream.subscribe(<span class="keyword">new</span> BodyObserver&lt;T&gt;(observer));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyObserver</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">Response</span>&lt;<span class="title">R</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> R&gt; observer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> terminated;</span><br><span class="line"></span><br><span class="line">    BodyObserver(Observer&lt;? <span class="keyword">super</span> R&gt; observer) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// BodyObserver实现了Observer的4个方法onSubscribe、onNext、onComplete、onError，</span></span><br><span class="line"><span class="comment">// 但是不是BodyObserver自己完成的，而是通过传入的observer代替完成大部分功能，而BodyObserver</span></span><br><span class="line"><span class="comment">// 只对传过来的Response进行简单判断就交给observer了</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable disposable)</span> </span>&#123;</span><br><span class="line">      observer.onSubscribe(disposable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">        <span class="comment">// 比如判断response是否是成功从服务器返回的，然后交给observer的onNext方法，</span></span><br><span class="line">        <span class="comment">// 此时传给observer的就是response的body了，对应我们使用的GsonConverterFactory，</span></span><br><span class="line">        <span class="comment">// 那这个body就是WeatherEntity实例</span></span><br><span class="line">        observer.onNext(response.body());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        terminated = <span class="keyword">true</span>;</span><br><span class="line">        Throwable t = <span class="keyword">new</span> HttpException(response);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(inner);</span><br><span class="line">          RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!terminated) &#123;</span><br><span class="line">        observer.onComplete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!terminated) &#123;</span><br><span class="line">        observer.onError(throwable);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This should never happen! onNext handles and forwards errors automatically.</span></span><br><span class="line">        Throwable broken = <span class="keyword">new</span> AssertionError(</span><br><span class="line">            <span class="string">"This should never happen! Report as a bug with the full stacktrace."</span>);</span><br><span class="line">        <span class="comment">//noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.</span></span><br><span class="line">        broken.initCause(throwable);</span><br><span class="line">        RxJavaPlugins.onError(broken);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完Observable后紧接着是subscribeOn、observeOn以及subscribe方法，很显然这些方法都是Observable的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observable.java</span></span><br><span class="line">    <span class="meta">@CheckReturnValue</span></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observable.java</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一般来说onObservableAssembly在没有调用reset方法的情况下为空，所以这里肯定为空</span></span><br><span class="line">        Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> apply(f, source);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 也就是说这个onAssembly方法直接返回了source，所以上面的subscribeOn方法返回的是ObservableSubscribeOn</span></span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>subscribeOn方法之后我们得到了一个新的ObservableSubscribeOn，<a href="http://xn--BodyObservableSchedulers-fw12b88d4ukcom82ivyi9go50urfbb77r75wg.io" target="_blank" rel="noopener">它保存了BodyObservable以及加入的参数Schedulers.io</a>()，接下来继续调用observeOn</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observable.java</span></span><br><span class="line">    <span class="meta">@CheckReturnValue</span></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CheckReturnValue</span></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">        ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">        <span class="comment">// observeOn显然又返回了一个ObservableObserveOn</span></span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>observeOn方法之后我们得到了新的ObservableObserveOn，它保存了ObservableSubscribeOn以及参数AndroidSchedulers.mainThread()，最后调用subscribe方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observable.java</span></span><br><span class="line">    <span class="meta">@CheckReturnValue</span></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe方法可以接受多种参数，比如我这里对应上面的两个Consumer参数，其中第一个Consumer名字是onNext，</span></span><br><span class="line">        <span class="comment">// 第二个Consumer名字是onError，看到这里基本上明白了这两个Consumer的功能，就是执行处理onNext传入的数据以及处理</span></span><br><span class="line">        <span class="comment">// onError传入的异常</span></span><br><span class="line">        <span class="keyword">return</span> subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CheckReturnValue</span></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></span><br><span class="line"><span class="function"><span class="params">            Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(onNext, <span class="string">"onNext is null"</span>);</span><br><span class="line">        ObjectHelper.requireNonNull(onError, <span class="string">"onError is null"</span>);</span><br><span class="line">        ObjectHelper.requireNonNull(onComplete, <span class="string">"onComplete is null"</span>);</span><br><span class="line">        ObjectHelper.requireNonNull(onSubscribe, <span class="string">"onSubscribe is null"</span>);</span><br><span class="line">        <span class="comment">// 然后对onNext、onError、onComplete、onSubscribe四个Consumer进行封装，</span></span><br><span class="line">        <span class="comment">// 整合成一个LambdaObserver，也就是说，本质上我们subscribe的参数最终还是Observer</span></span><br><span class="line">        LambdaObserver&lt;T&gt; ls = <span class="keyword">new</span> LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span><br><span class="line"></span><br><span class="line">        subscribe(ls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// RxJavaPlugins.onSubscribe类似上面的onAssembly方法，这里没有做任何操作</span></span><br><span class="line">            <span class="comment">// 等价于observer = observer</span></span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">            ObjectHelper.requireNonNull(observer, <span class="string">"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"</span>);</span><br><span class="line">            <span class="comment">// 然后调用subscribeActual，要知道ObservableObserveOn中重写了subscribeActual方法，所以我们再回到</span></span><br><span class="line">            <span class="comment">// ObservableObserveOn中，需要记住的是这个observer保存了我们定义的两个Consumer</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">            <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">            RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">            NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">            npe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面的构造Observable的顺序是：CallExecuteObservable -&gt; BodyObservable -&gt; ObservableSubscribeOn -&gt; ObservableObserveOn，每一级Observable都是以上一级Observable作为参数够早的，CallExecuteObservable和BodyObservable是没有设置Scheduler参数的，ObservableSubscribeOn和ObservableObserveOn有Scheduler参数，Scheduler参数决定了Observer执行的线程；当我们调用subscribe方法会自底向上依次调用Observable的subscribeActual方法，在调用subscribeActual方法是会调用上一级的subscribe方法，传入的参数就是Observer，Observer的构造顺序是：自定义Consumer -&gt; LambdaObserver -&gt; ObserveOnObserver -&gt; SubscribeOnObserver -&gt; BodyObserver，最顶层的CallExecuteObservable是没有Observer的，每一级的Observer都会以下一级的Observer作为参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableObserveOn.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// source就是ObservableObserveOn构造时传入的第一个参数，对应ObservableSubscribeOn，</span></span><br><span class="line">        <span class="comment">// 由于scheduler对应AndroidSchedulers.mainThread()，本质上是HandlerScheduler</span></span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用的是HandlerScheduler的createWorker方法,返回的是HandlerWorker，</span></span><br><span class="line">            <span class="comment">// HandlerWorker保存了两个参数，一个是Handler，另一个bool async，</span></span><br><span class="line">            <span class="comment">// 因为AndroidSchedulers.mainThread()，所以此处的Handler是new Handler(Looper.getMainLooper())，</span></span><br><span class="line">            <span class="comment">// 即主线程中的Handler，async为false</span></span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">            <span class="comment">// 构造新的ObserveOnObserver，传入的参数有LambdaObserver和HandlerWorker</span></span><br><span class="line">            <span class="comment">// 然后调用ObservableSubscribeOn的subscribe方法，这是一个递归调用，subscribe就是上面的，</span></span><br><span class="line">            <span class="comment">// 又因为subscribeActual，所以还是调用ObservableSubscribeOn的subscribeActual方法</span></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们走到了ObservableSubscribeOn的subscribeActual方法时，需要开始使用observer（上一级Observable的内部类Observer）进行预处理或者发送数据，因为RxJava的onSubscribe是最先被调用的，所以我们需要先调用onSubscribe方法，会依次向上调用Observer的onSubscribe方法，由于Observer保存了如何发送数据的方法onNext以及处理异常的方法onError以及表示已完成的onComplete，所以如果传到最上级的Observable，那么就可以在CallExecuteObservable的subscribeActual方法中调用传入的Observer的各种方法，从而对数据进行发送、处理等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableSubscribeOn.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// observer是上面构造的ObserveOnObserver，将其转换为SubscribeOnObserver</span></span><br><span class="line">        <span class="comment">// 将上一级传进来的订阅者包装为线程安全的原子变量</span></span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line">        <span class="comment">// 然后调用ObserveOnObserver的onSubscribe，调用onSubscribe即开始预处理，onSubscribe会调用</span></span><br><span class="line">        <span class="comment">// 我们定义的Consumer（本示例未使用onSubscribe的Consumer，所以没有做任何操作）</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">        <span class="comment">// ObservableSubscribeOn的scheduler对应Schedulers.io()，即IoScheduler</span></span><br><span class="line">        <span class="comment">// SubscribeTask会被放在BlockingQueue队列中，这里就是开始执行我们实际请求的关键转折了，</span></span><br><span class="line">        <span class="comment">// 之前都是铺垫，然后在指定的线程中执行source(上一级)的subscribe，即IO线程的工作</span></span><br><span class="line">        <span class="comment">// source.subscribe(parent)，这里的source实际就是BodyObservable</span></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的source是BodyObservable</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>scheduler的作用就是通过内部Worker将task交给线程池进行处理，因为ObservableSubscribeOn是通过调用subscribeOn方法生成的，因此很大程度上会运行在其他线程，也就是说SubscribeTask的run方法是执行在Worker的线程池中，即从现在开始的subscribe都是在Worker线程中而不是主线程了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scheduler.java</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleDirect(run, <span class="number">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个createWorker就是IoScheduler的createWorker，返回的是EventLoopWorker，此EventLoopWorker</span></span><br><span class="line">        <span class="comment">// 运行的线程通过线程池CachedWorkerPool提供</span></span><br><span class="line">        <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</span><br><span class="line">        <span class="comment">// w.schedule会在ScheduledThreadPoolExecutor中安排task被执行，task会被放在队列中</span></span><br><span class="line">        w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在看BodyObservable的subscribe方法前先看一下onSubscribe做了些什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableObserveOn.java 内部类ObserveOnObserver的onSubscribe方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.upstream, d)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.upstream = d;</span><br><span class="line">                <span class="comment">// 这里的d是SubscribeOnObserver，所以跳过</span></span><br><span class="line">                <span class="keyword">if</span> (d <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) d;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">                        sourceMode = m;</span><br><span class="line">                        queue = qd;</span><br><span class="line">                        done = <span class="keyword">true</span>;</span><br><span class="line">                        downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">                        schedule();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">                        sourceMode = m;</span><br><span class="line">                        queue = qd;</span><br><span class="line">                        downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这个队列用于保存数据，之后会用，bufferSize大小默认是128</span></span><br><span class="line">                queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">                <span class="comment">// 而downstream是ObserveOnObserver构造函数的第一个参数，即我们调用subscribe方法时</span></span><br><span class="line">                <span class="comment">// 传入的LambdaObserver（但是通过Consumer实现的）</span></span><br><span class="line">                downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaObserver.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DisposableHelper.setOnce(<span class="keyword">this</span>, d)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// onSubscribe也只是调用onSubscribe.accept，还记得上面我们的LambdaObserver构造时仅使用了</span></span><br><span class="line">                <span class="comment">// onNext和onError，所以onSubscribe其实是空的，这里没有任何作用</span></span><br><span class="line">                onSubscribe.accept(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(ex);</span><br><span class="line">                d.dispose();</span><br><span class="line">                onError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回到subscribe的调用链，在子线程（线程池）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BodyObservable.java</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的upstream是CallExecuteObservable</span></span><br><span class="line">    upstream.subscribe(<span class="keyword">new</span> BodyObserver&lt;T&gt;(observer));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过subscribe最终调用到了最顶层的Observable的subscribeActual方法，且传入的下一级的内部类Observer，用于提供onXXX方法传递数据，执行在子线程（线程池）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallExecuteObservable.java</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></span><br><span class="line">    Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line">    CallDisposable disposable = <span class="keyword">new</span> CallDisposable(call);</span><br><span class="line">    <span class="comment">// CallExecuteObservable是我们实际开始调用Retrofit请求数据的开始</span></span><br><span class="line">    <span class="comment">// 首先需要调用observer的onSubscribe，这里是BodyObserver，</span></span><br><span class="line">    <span class="comment">// 还记得上面的LambdaObserver的onSubscribe，</span></span><br><span class="line">    <span class="comment">// 这里其实什么事情都没有做</span></span><br><span class="line">    observer.onSubscribe(disposable);</span><br><span class="line">    <span class="keyword">if</span> (disposable.isDisposed()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 然后调用call.execute()，如果记得Retrofit，那么就知道这里发出了请求，也就是说这个方法执行在IO线程</span></span><br><span class="line">      Response&lt;T&gt; response = call.execute();</span><br><span class="line">      <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        <span class="comment">// 然后通过onNext方法将结果发射出去，这个observer就是BodyObserver</span></span><br><span class="line">        observer.onNext(response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        terminated = <span class="keyword">true</span>;</span><br><span class="line">        observer.onComplete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Exceptions.throwIfFatal(t);</span><br><span class="line">      <span class="keyword">if</span> (terminated) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(inner);</span><br><span class="line">          RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>onNext方法的向下一级传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BodyObservable.java 内部类BodyObserver的onNext方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">        <span class="comment">// BodyObserver判断了一下请求结果response，然后将body发射出去</span></span><br><span class="line">        <span class="comment">// 这里的observer就是SubscribeOnObserver</span></span><br><span class="line">        observer.onNext(response.body());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        terminated = <span class="keyword">true</span>;</span><br><span class="line">        Throwable t = <span class="keyword">new</span> HttpException(response);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(inner);</span><br><span class="line">          RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableSubscribeOn.java 内部类SubscribeOnObserver</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的downstream是ObserveOnObserver</span></span><br><span class="line">            downstream.onNext(t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里因为ObservableObserveOn是通过observeOn创建的，而这里发生了线程切换，我们的例子中是主线程，所以需要通过Handler将后续的任务切换到主线程中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableObserveOn.java 内部类ObserveOnObserver</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">                <span class="comment">// 这里的queue是SpscLinkedArrayQueue，我们把传出来的数据保存在队列中了</span></span><br><span class="line">                queue.offer(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最终调用schedule</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// worker是初始化时调用observeOn传入的主线程的HandlerScheduler的内部类HandlerWorker，</span></span><br><span class="line">                <span class="comment">// 这里的schedule方法传入this，即ObserveOnObserver，与此同时ObserveOnObserver</span></span><br><span class="line">                <span class="comment">// 实现了Runnable的接口，可以作为Runnable，它的run方法会在下面被执行</span></span><br><span class="line">                worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerScheduler.java 内部类HandlerWorker</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressLint</span>(<span class="string">"NewApi"</span>) <span class="comment">// Async will only be true when the API is available to call.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"run == null"</span>);</span><br><span class="line">            <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit == null"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (disposed) &#123;</span><br><span class="line">                <span class="keyword">return</span> Disposables.disposed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            run = RxJavaPlugins.onSchedule(run);</span><br><span class="line">            <span class="comment">// HandlerWorker的schedule方法，我们传入的run即上面的ObserveOnObserver</span></span><br><span class="line">            <span class="comment">// ScheduledRunnable也是Runnable，但是它的run方法仅仅是调用了传入的run的run方法</span></span><br><span class="line">            <span class="comment">// 也就是说如果我们执行了scheduled的run方法等价于执行了run的方法，也就是</span></span><br><span class="line">            <span class="comment">// ObserveOnObserver的run方法</span></span><br><span class="line">            ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line">            <span class="comment">// scheduled的run方法执行是通过handler处理的，通过sendMessageDelayed实现的</span></span><br><span class="line">            Message message = Message.obtain(handler, scheduled);</span><br><span class="line">            message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for batch disposal of this worker's runnables.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                message.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 也就是在这里我们将在主线程执行ObserveOnObserver的run方法</span></span><br><span class="line">            handler.sendMessageDelayed(message, unit.toMillis(delay));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Re-check disposed state for removing in case we were racing a call to dispose().</span></span><br><span class="line">            <span class="keyword">if</span> (disposed) &#123;</span><br><span class="line">                handler.removeCallbacks(scheduled);</span><br><span class="line">                <span class="keyword">return</span> Disposables.disposed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> scheduled;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableObserveOn.java 内部类ObserveOnObserver</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">                drainFused();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里执行的是drainNormal</span></span><br><span class="line">                drainNormal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 还记得上面的SpscLinkedArrayQueue，之前我们在onNext方法中把传过来的数据保存在队列中</span></span><br><span class="line">            <span class="comment">// 接下来需要从队列中取出数据</span></span><br><span class="line">            <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">            <span class="comment">// downstream即LambdaObserver</span></span><br><span class="line">            <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = downstream;</span><br><span class="line">            <span class="comment">// 这里用循环是因为RxJava支持连续发送多个数据，那么最终数据都保存在队列中</span></span><br><span class="line">            <span class="comment">// 所以取数据的时候就可以通过循环来一次性获取队列中的所有数据，而SpscLinkedArrayQueue</span></span><br><span class="line">            <span class="comment">// 的最大容量，根据之前的代码我们知道是128</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> d = done;</span><br><span class="line">                    T v;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// q.poll从队列中取出数据</span></span><br><span class="line">                        v = q.poll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        Exceptions.throwIfFatal(ex);</span><br><span class="line">                        disposed = <span class="keyword">true</span>;</span><br><span class="line">                        upstream.dispose();</span><br><span class="line">                        q.clear();</span><br><span class="line">                        a.onError(ex);</span><br><span class="line">                        worker.dispose();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a即为LambdaObserver，v为我们从队列中取出来的数据，也是</span></span><br><span class="line">                    <span class="comment">// 我们通过handler传入的数据，通过onNext发出，而这个onNext</span></span><br><span class="line">                    <span class="comment">// 就是我们定义的第一个Consumer，通过这个Consumer的accept方法</span></span><br><span class="line">                    <span class="comment">// 在主线程实现TextView的设置</span></span><br><span class="line">                    a.onNext(v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                missed = addAndGet(-missed);</span><br><span class="line">                <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LambdaObserver.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 我们定义的Consumer的accept方法</span></span><br><span class="line">                onNext.accept(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                get().dispose();</span><br><span class="line">                onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>综上，RxJava的简单源码分析流程就完成了，整个RxJava调用流程可以分为两个阶段：构造阶段和subscribe阶段，在调用subscribe方法前的步骤我称之为构造阶段，这个过程中主要工作是创建被观察者Observable，每一次使用RxJava的方法时都会创建新的Observable，每个新的Observable都会以上一级的Observable作为参数，其中部分Observable还需要Scheduler参数，用于切换线程，构造阶段仅仅是将Observable连接起来；在调用subscribe方法时开始了subscribe阶段，这个阶段的任务是将我们自定义的Consumer（或者可以当作观察者Observer）通过Observable的subscribe方法连接起来（subscribe的过程中可能会调用onSubscribe方法进行预处理，初始化一些队列什么的，onSubscribe方法与onNext、onError、onComplete方法有点区别），当我们的subscribe方法走到最顶层时会开始启动Observer的onXXX方法传递数据或者传出异常等等，因为之前已经将Observer连接起来，所以此时onXXX方法的调用也是链式的，层层向下传递，直到调用我们自定义的Consumer（在此过程中会通过在构造阶段传入的Scheduler实现线程切换）。</p>
<p>如果完整的看过一遍分析流程就会发现其实Observable和Observer的调用链是很简单的，但是随之也有几个疑问：</p>
<blockquote>
<p>1.为什么要用Observable和Observer的形式？</p>
</blockquote>
<p>首先需要明白的是，RxJava的目的是提供一个便于进行数据处理的框架，通过流式调用实现线程切换、数据类型转换等，也就是说数据从A -&gt; B -&gt; C可以是不同类型的数据或者是在不同线程处理，最适合的模式就是观察者模式，比如我们常见的OnClickListener，它传递的是点击事件，再比如我们自定义的传递数据的接口回调，都是观察者模式。简而言之就是，A通过B提供的接口将数据传到B中进行处理，B通过C提供的接口将数传到C中进行处理，由此可以进行数据的传递，当然这只是数据传递的流程，具体的调用流程就是上面的总结。使用Observable和Observer的形式，一是便于我们自定义数据转换的Observable和Observer，二是可以实现流式调用，三是这里面实现了这种接口回调的功能。</p>
<blockquote>
<p>2.subscribeOn和observeOn是如何切换线程的？</p>
</blockquote>
<p>subscribeOn会指定我们在调用subscribeOn之前的Observable中数据处理的线程，observeOn会指定我们在调用observeOn之后的Observable中数据处理的线程。这是因为两者切换线程的位置不同，subscribeOn会在subscribeActual的方法中切换线程，导致后续所有的调用都是在subscribeOn指定的线程中，而subscribeActual方法是自底向上调用的，因此会影响subscribeOn之前的所有方法；而observeOn是在ObserveOnObserver的onNext方法中进行线程切换的，因此会影响observeOn后面数据传递的方法。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">推荐文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/b0107659.html" rel="bookmark">Android框架-Gson</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/d1370632.html" rel="bookmark">Material组件-Snackbar</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/c75dc4ab.html" rel="bookmark">Android IPC-AIDL、Messenger和Socket</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/bb3604db.html" rel="bookmark">Android-Q适配-存储方式</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/2943f9f3.html" rel="bookmark">Android-共享元素动画效果</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Tao Zhou
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zhoutao822.coding.me/archives/686da54d.html" title="Android框架-RxJava">http://zhoutao822.coding.me/archives/686da54d.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/Handler/" rel="tag"># Handler</a>
              <a href="/tags/AsyncTask/" rel="tag"># AsyncTask</a>
              <a href="/tags/EventBus/" rel="tag"># EventBus</a>
              <a href="/tags/RxJava/" rel="tag"># RxJava</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/d1370632.html" rel="prev" title="Material组件-Snackbar">
      <i class="fa fa-chevron-left"></i> Material组件-Snackbar
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/c75dc4ab.html" rel="next" title="Android IPC-AIDL、Messenger和Socket">
      Android IPC-AIDL、Messenger和Socket <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-handler"><span class="nav-text"> 1. Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-handler简单使用"><span class="nav-text"> 1.1 Handler简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-handler线程间通信"><span class="nav-text"> 1.2 Handler线程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-handler源码分析"><span class="nav-text"> 1.3 Handler源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-handler进阶"><span class="nav-text"> 1.4 Handler进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-asynctask"><span class="nav-text"> 2. AsyncTask</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-asynctask简单使用"><span class="nav-text"> 2.1 AsyncTask简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-asynctask源码分析"><span class="nav-text"> 2.2 AsyncTask源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-eventbus"><span class="nav-text"> 3. EventBus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-rxjava"><span class="nav-text"> 4. RxJava</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-rxjava结合retrofit"><span class="nav-text"> 4.1 RxJava结合Retrofit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-rxjava源码分析"><span class="nav-text"> 4.2 RxJava源码分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tao Zhou"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Tao Zhou</p>
  <div class="site-description" itemprop="description">学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tao Zhou</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">955k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:28</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
              leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz',
            'X-LC-Key': 'xoukWFyqvFIXJ6DfxLLYtsTP',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz',
      appKey: 'xoukWFyqvFIXJ6DfxLLYtsTP',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
