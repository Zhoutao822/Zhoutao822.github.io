<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://zhoutao822.coding.me').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="参考：  《解析深度学习-语音识别实践》第3章 隐马尔可夫模型及其变体西瓜书第7章 贝叶斯分类器机器学习系列之EM算法HMM模型和Viterbi算法  语音识别过程：切除首尾端静音-&gt;声音划分为帧-&gt;对每一帧提取MFCC特征-&gt;若干帧对应一个状态-&gt;三个状态组成一个音素-&gt;若干音素组成单词 1. 马尔可夫链马尔可夫链是一种离散状态的马尔可夫序列，也是一般性马尔可夫序列">
<meta property="og:type" content="article">
<meta property="og:title" content="语音识别-HMM">
<meta property="og:url" content="http://zhoutao822.coding.me/archives/2f863467.html">
<meta property="og:site_name" content="Tao">
<meta property="og:description" content="参考：  《解析深度学习-语音识别实践》第3章 隐马尔可夫模型及其变体西瓜书第7章 贝叶斯分类器机器学习系列之EM算法HMM模型和Viterbi算法  语音识别过程：切除首尾端静音-&gt;声音划分为帧-&gt;对每一帧提取MFCC特征-&gt;若干帧对应一个状态-&gt;三个状态组成一个音素-&gt;若干音素组成单词 1. 马尔可夫链马尔可夫链是一种离散状态的马尔可夫序列，也是一般性马尔可夫序列">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhoutao822.coding.me/archives/2f863467/hmm.png">
<meta property="article:published_time" content="2018-11-16T07:33:47.000Z">
<meta property="article:modified_time" content="2020-01-17T15:07:46.276Z">
<meta property="article:author" content="Tao Zhou">
<meta property="article:tag" content="Theory">
<meta property="article:tag" content="HMM">
<meta property="article:tag" content="EM Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zhoutao822.coding.me/archives/2f863467/hmm.png">

<link rel="canonical" href="http://zhoutao822.coding.me/archives/2f863467.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>语音识别-HMM | Tao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Tao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zhoutao822.coding.me/archives/2f863467.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Tao Zhou">
      <meta itemprop="description" content="学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tao">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          语音识别-HMM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-16 15:33:47" itemprop="dateCreated datePublished" datetime="2018-11-16T15:33:47+08:00">2018-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-17 23:07:46" itemprop="dateModified" datetime="2020-01-17T23:07:46+08:00">2020-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Speech-Recognition/" itemprop="url" rel="index">
                    <span itemprop="name">Speech Recognition</span>
                  </a>
                </span>
            </span>

          
            <span id="/archives/2f863467.html" class="post-meta-item leancloud_visitors" data-flag-title="语音识别-HMM" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/2f863467.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/2f863467.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>参考：</p>
<blockquote>
<p>《解析深度学习-语音识别实践》第3章 隐马尔可夫模型及其变体<br>西瓜书第7章 贝叶斯分类器<br><a href="https://www.cnblogs.com/Gabby/p/5344658.html" target="_blank" rel="noopener">机器学习系列之EM算法</a><br><a href="https://www.cnblogs.com/Denise-hzf/p/6612212.html" target="_blank" rel="noopener">HMM模型和Viterbi算法</a></p>
</blockquote>
<p><strong>语音识别过程：切除首尾端静音-&gt;声音划分为帧-&gt;对每一帧提取MFCC特征-&gt;若干帧对应一个状态-&gt;三个状态组成一个音素-&gt;若干音素组成单词</strong></p>
<h2 id="1-马尔可夫链"><a href="#1-马尔可夫链" class="headerlink" title="1. 马尔可夫链"></a>1. 马尔可夫链</h2><p>马尔可夫链是一种离散状态的马尔可夫序列，也是一般性马尔可夫序列的特殊形式。<br>马尔可夫链的状态空间具有离散和有限性：$q_t \in { s^{(j)},j = 1,2,…,N}$。每一个离散值都与马尔可夫链中的一个状态相关。</p>
<p>一个马尔可夫链$\boldsymbol{q}_1^T = q_1, q_2,…,q_T$，可被转移概率完全表示，定义为</p>
<p>$$<br>P(q_t=s^{(j)}|q_{t-1}=s^{(i)}) = a_{ij}(t) \quad i,j=1,2,…,N<br>$$</p>
<p>以及初始状态分布概率。如果这些转移概率与时间$t$无关，则得到齐次马尔可夫链。</p>
<p>（齐次）马尔可夫链的转移概率通常能方便地表示为矩阵形式：</p>
<p>$$<br>\boldsymbol{A} = [a_{ij}], \quad 其中a_{ij} \geqslant 0 \quad \forall i,j ; \sum^N_{j=1}a_{ij}=1 \quad \forall i<br>$$</p>
<p>$\boldsymbol{A}$称为马尔可夫链的转移矩阵。给定马尔可夫链的转移概率，则状态输出概率</p>
<p>$$<br>p_j(t) = P[q_t = s^{(j)}]<br>$$</p>
<a id="more"></a>

<p>很容易得到，递归计算</p>
<p>$$<br>p_i(t+1) = \sum^N_{j=1} a_{ji}p_j(t), \quad \forall i<br>$$</p>
<p>如果马尔可夫链的状态占有分布式渐进收敛：$p_i(t) \rightarrow \pi(q^{(i)})$，当$t \rightarrow \infty$，我们称$p(s^{(i)})$为马尔可夫链的一个稳态分布。对有稳态分布的马尔可夫链来说，他的转移概率$a_{ij}$必须满足：</p>
<p>$$<br>\bar{\pi}(s^{(i)}) = \sum^N_{j=1}a_{ji}\bar{\pi}(s^{(j)}), \quad \forall i<br>$$</p>
<p>马尔可夫链的稳态分布在马尔可夫链蒙特卡洛（MCMC）方法中起着重要作用。这些方法用来模拟（即采样）任意复杂的分布函数，使其能执行很多复杂的统计推断和学习任务，否则这些任务运算困难。MCMC方法的理论基础是马尔可夫链到它的稳态分布$\bar{\pi}(s^{(i)})$的渐进收敛。也就是说，无论初始分布如何，马尔可夫链之于$\bar{\pi}(s^{(i)})$是渐进无偏的。因此，为了从任意的复合分布$p(s)$中采样，可以通过设计合适的转移概率构造一个马尔可夫链，使它的稳态分布为$\bar{\pi}(s) = p(s)$。</p>
<p>三种马尔可夫链的性质：</p>
<ul>
<li>马尔可夫链的状态时长是一个指数或几何级分布：$p_i(d)=C(a_{ii})^{d-1}$，其中归一化常数为$C = 1 - a_{ii}$；</li>
<li>平均状态时长为</li>
</ul>
<p>$$<br>\bar{d}<em>i = \sum^{\infty}</em>{d=1}dp_i(d) = \sum^{\infty}<em>{d=1}(1-a</em>{ii})(a_{ii})^{d-1} = \frac{1}{1-a_{ii}}<br>$$</p>
<ul>
<li>对任意一个服从马尔可夫链的观察序列，若它对应有限长度状态序列$\boldsymbol{q}^T_1$，则其概率很容易计算，是所有马尔可夫链的转移概率的乘积：$P(\boldsymbol{q}^T_1) = \bar{\pi}<em>{q_1}\prod^{T-1}</em>{t=1}a_{q_tq_{t+1}}$，其中$\bar{\pi}_{s_1}$使当$t=1$时的初始状态输出概率。</li>
</ul>
<h2 id="2-序列与模型"><a href="#2-序列与模型" class="headerlink" title="2. 序列与模型"></a>2. 序列与模型</h2><p>马尔可夫链的每一种状态与一种输出（观察值或事件）一一对应，没有随机性。</p>
<p>隐马尔可夫序列在各个状态引入一种随机性，用一个观测的概率分布与每一个状态对应，而不是一个确定的事件或观察值。</p>
<img src="/archives/2f863467/hmm.png" class="" title="隐马尔可夫模型">

<p>即我们观察到的是$x_i$，而观测值仅由隐藏的状态$y_i$决定，而当前时刻的状态$y_i$仅由前一时刻的状态$y_{i-1}$决定。</p>
<h3 id="2-1-隐马尔可夫模型的性质"><a href="#2-1-隐马尔可夫模型的性质" class="headerlink" title="2.1 隐马尔可夫模型的性质"></a>2.1 隐马尔可夫模型的性质</h3><ul>
<li>齐次马尔可夫链的转移概率矩阵$\boldsymbol{A}=[a_{ij}] \quad i,j = 1,2,…,N$，其中共有$N$个状态</li>
</ul>
<p>$$<br>a_{ij} = P(q_t = j | q_{t-1}=i) \quad i,j = 1,2,…,N<br>$$</p>
<ul>
<li>马尔可夫链的初始概率：$\pi = [\pi_i] \quad i= 1,2,…,N$，其中$\pi_i = P(q_1 = i)$；</li>
<li>观察概率分布为$P(\boldsymbol{o}_t|s^{(i)}) \quad i=1,2,…,N$。若$\boldsymbol{o}_t$是离散的，每个状态对应的概率分布用来描述观察${ \boldsymbol{v}_1, \boldsymbol{v}_2,…,\boldsymbol{v}_K}$的概率：</li>
</ul>
<p>$$<br>b_i(k) = P(\boldsymbol{o}_t = \boldsymbol{v}_k|q_t = i) \quad i=1,2,…,N<br>$$</p>
<p>若观察概率分布是连续的，那么概率密度函数PDF中的参数$\Lambda_i$代表HMM状态$i$的特性</p>
<hr>
<p>在语音处理问题中，我们用HMM下的PDF来描述连续观察向量（$\boldsymbol{o}_t \in \mathbb{R}^D$）的概率分布，其中多元混合高斯分布是最成功、应用最广泛的PDF：</p>
<p>$$<br>b_i(\boldsymbol{o}<em>t) = \sum^M</em>{m=1}\frac{c_{i,m}}{(2\pi)^{D/2}|\boldsymbol{\Sigma}<em>{i,m}|^{1/2}}\exp[-\frac{1}{2}(\boldsymbol{o}_t - \boldsymbol{\mu}</em>{i,m})^T\boldsymbol{\Sigma}^{-1}<em>{i,m}(\boldsymbol{o}_t - \boldsymbol{\mu}</em>{i,m})]<br>$$</p>
<p>在混合高斯HMM中，参数集$\Lambda_i$包括混合权重成分$c_{i,m}$，高斯分布均值向量$\boldsymbol{\mu}<em>{i,m} \in \mathbb{R}^D$与协方差矩阵$\boldsymbol{\Sigma}</em>{i,m} \in \mathbb{R}^{D \times D}$。</p>
<p>有了模型参数后，高斯HMM可以看作是一个观察值序列$\boldsymbol{o}_t，t =1,2,…,T$的生成器。在$t$时刻，数据根据公式</p>
<p>$$<br>\boldsymbol{o}_t = \boldsymbol{\mu}_i + \boldsymbol{r}_t(\boldsymbol{\Sigma}_i)<br>$$</p>
<p>生成，其中时刻$t$的状态$i$取决于马尔可夫链的演变，受$a_{ij}$影响，且</p>
<p>$$<br>\boldsymbol{r}_t(\boldsymbol{\Sigma}_i) = N(0, \boldsymbol{\Sigma}_i)<br>$$<br>是均值为0、依赖序号$i$的IID（独立同分布）的高斯剩余序列。</p>
<hr>
<p>有一个对平稳状态的HMM的简单扩展，可以使其观察序列不再是状态限制下的IID。修改常量$\boldsymbol{\mu}_i$，使其随时间而变化：</p>
<p>$$<br>\boldsymbol{o}_t = \boldsymbol{g}_t(\Lambda_i) + \boldsymbol{r}_t(\boldsymbol{\Sigma}_i)<br>$$</p>
<p>在状态$i$下，确定性的时间变化轨迹函数$\boldsymbol{g}_t(\Lambda_i)$中的参数是独立的。这便是高斯趋势HMM，这是一种特殊的非平稳状态的HMM，其中一阶统计量（均值）是随时间变化的。</p>
<h3 id="2-2-隐马尔可夫模型似然度的计算"><a href="#2-2-隐马尔可夫模型似然度的计算" class="headerlink" title="2.2 隐马尔可夫模型似然度的计算"></a>2.2 隐马尔可夫模型似然度的计算</h3><p>设$\boldsymbol{q}_1^T = (q_1, …, q_T)$是GMM-HMM中的一个有限长度状态序列，$P(\boldsymbol{o}_1^T, \boldsymbol{q}^T_1)$是观察序列$\boldsymbol{o}_1^T = (\boldsymbol{o}_1,…,\boldsymbol{o}_T)$和状态序列$\boldsymbol{q}^T_1$的联合概率。令$P(\boldsymbol{o}_1^T|\boldsymbol{q}_1^T)$表示状态序列$\boldsymbol{q}_1^T$的条件下生成观察序列$\boldsymbol{o}_1^T$的概率。</p>
<p>在GMM-HMM中条件概率$P(\boldsymbol{o}_1^T|\boldsymbol{q}_1^T)$表示为（这里使用$b_i(\boldsymbol{o}_t)$并不准确，因为状态序列的状态i应该在改变，但是对每一个状态来说是独立同分布，都是一个高斯分布形式）：</p>
<p>$$<br>P(\boldsymbol{o}<em>1^T|\boldsymbol{q}_1^T) = \prod^T</em>{t=1}b_i(\boldsymbol{o}<em>t)<br>\<br>= \prod^T</em>{t=1}\sum^M_{m=1}\frac{c_{i,m}}{(2\pi)^{D/2}|\boldsymbol{\Sigma}<em>{i,m}|^{1/2}}\exp[-\frac{1}{2}(\boldsymbol{o}_t - \boldsymbol{\mu}</em>{i,m})^T\boldsymbol{\Sigma}^{-1}<em>{i,m}(\boldsymbol{o}_t - \boldsymbol{\mu}</em>{i,m})]<br>$$</p>
<p>另一方面，状态序列$\boldsymbol{q}_1^T$的概率为转移概率乘积</p>
<p>$$<br>P(\boldsymbol{q}<em>1^T) = \pi</em>{q_1}\prod^{T-1}<em>{t=1}a</em>{q_tq_{t+1}}<br>$$</p>
<p>为了记号上的简便，考虑初始状态分布的概率为1（$\pi_{q_1} = 1$）</p>
<p>联合概率$P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T)$可以通过上式乘积得到</p>
<p>$$<br>P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T) = P(\boldsymbol{o}_1^T|\boldsymbol{q}_1^T) P(\boldsymbol{q}_1^T)<br>$$</p>
<p>原则上可以通过累加状态序列下的联合概率计算总体观察序列似然度</p>
<p>$$<br>P(\boldsymbol{o}<em>1^T) = \sum</em>{\boldsymbol{q}_1^T}P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T)<br>$$</p>
<p>然而，在长度为$T$下运算是指数级的复杂度（若状态总计$N$种，那么状态序列的种类为$N^T$），所以不可行。使用前向算法计算，复杂度与$T$是线性的。</p>
<h3 id="2-3-计算似然度"><a href="#2-3-计算似然度" class="headerlink" title="2.3 计算似然度"></a>2.3 计算似然度</h3><p>首先定义马尔可夫链每个状态$i$下的前向概率（物理意义为在$t$时刻观察序列为$\boldsymbol{o}_1^t$且时刻$t$的状态为$i$的概率）</p>
<p>$$<br>\alpha_t(i) = P(q_t=i,\boldsymbol{o}_1^t), \quad t = 1,…,T<br>$$</p>
<p>与后向概率（物理意义为在$t$时刻状态为$i$的条件下，从$t+1$到$T$的观察序列为$\boldsymbol{o}^T_{t+1}$的概率）</p>
<p>$$<br>\beta_t(i) = P(\boldsymbol{o}^T_{t+1}|q_t=i), \quad t = 1,…,T<br>$$</p>
<p>前向概率和后向概率递归计算方法：</p>
<p>$$<br>\alpha_t(j) = \sum^N_{i=1}\alpha_{t-1}(i)a_{ij}b_j(\boldsymbol{o}<em>t), \quad t = 2,3,…,T; \quad j = 1,2,…,N<br>\<br>\beta_t(i) = \sum^N</em>{j=1}\beta_{t+1}(j)a_{ij}b_j(\boldsymbol{o}_{t+1}), \quad t = T-1, T-2,…,1; \quad i =1,2,…,N<br>$$</p>
<p>前向概率的递归计算的物理层面可以理解为：首先考虑到$t-1$时刻，其状态可以取$N$种，然后从$t-1$时刻状态转移到$t$时刻状态$j$，需要转移概率，在状态$j$下的观察值为$\boldsymbol{o}_t$的概率为$b_j(\boldsymbol{o}_t)$。同理对后向概率。</p>
<p>$\alpha$递归式初始值为：</p>
<p>$$<br>\alpha_1(i) = P(q_1=i,\boldsymbol{o}_1) = P(q_1=i)P(\boldsymbol{o}_1|q_1)=\pi_ib_i(\boldsymbol{o}_1), \quad i = 1,2,…,N<br>$$</p>
<p>令$\beta$递归式初始值为：</p>
<p>$$<br>\beta_T(i) = 1, \quad i =1,2,…,N<br>$$</p>
<p>我们的目标是计算$P(\boldsymbol{o}_1^T)$，先对于每个状态$i$与$t = 1,2,…,T$，计算</p>
<p>$$<br>P(q_t = i,\boldsymbol{o}<em>1^T) = P(q_t=i, \boldsymbol{o}_1^t, \boldsymbol{o}^T</em>{t+1})<br>\<br>= P(q_t = i, \boldsymbol{o}<em>1^t)P(\boldsymbol{o}^T</em>{t+1}|\boldsymbol{o_1^t, q_t=i})<br>\<br>= P(q_t = i, \boldsymbol{o}<em>1^t)P(\boldsymbol{o}^T</em>{t+1}|q_t=i)<br>\<br>= \alpha_t(i)\beta_t(i)<br>$$</p>
<p>这样，$P(\boldsymbol{o}_1^T)$可以按照公式计算</p>
<p>$$<br>P(\boldsymbol{o}<em>1^T) = \sum^N</em>{i=1}P(q_t=i,\boldsymbol{o}<em>1^T) = \sum^N</em>{i=1}\alpha_t(i)\beta_t(i)<br>\<br>\forall t \in [1,T]<br>$$</p>
<p>将$t=T$代入上式，可以得出</p>
<p>$$<br>P(\boldsymbol{o}<em>1^T) = \sum^N</em>{i=1}\alpha_T(i)<br>$$</p>
<hr>
<p>前向概率递归</p>
<p>$$<br>\alpha_t(j) = P(q_t=j,\boldsymbol{o}<em>1^t)<br>\<br>= \sum^N</em>{i=1}P(q_{t-1} = i, q_t = j,\boldsymbol{o}<em>1^{t-1}, \boldsymbol{o}_t)<br>\<br>= \sum^N</em>{i=1}P(q_t=j,\boldsymbol{o}<em>t|q</em>{t-1} = i, \boldsymbol{o}<em>1^{t-1})P(q</em>{t-1} = i, \boldsymbol{o}<em>1^{t-1})<br>\<br>= \sum^N</em>{i=1}P(q_t=j,\boldsymbol{o}<em>t|q</em>{t-1} = i)\alpha_{t-1}(i)<br>\<br>= \sum^N_{i=1}P(\boldsymbol{o}<em>t|q_t=j,q</em>{t-1}=i)P(q_t=j|q_{t-1} = i)\alpha_{t-1}(i)<br>\<br>= \sum^N_{i=1}b_j(\boldsymbol{o}<em>t)a</em>{ij}\alpha_{t-1}(i)<br>$$</p>
<p>后向概率递归</p>
<p>$$<br>\beta_t(i) = P(\boldsymbol{o}<em>{t+1}^T|q_t=i)<br>\<br>= \frac{P(\boldsymbol{o}</em>{t+1}^T, q_t=i)}{P(q_t=i)}<br>\<br>=\frac{\sum^N_{j=1}P(\boldsymbol{o}^T_{t+1}, q_t=i,q_{t+1}=j)}{P(q_t=i)}<br>\<br>= \frac{\sum^N_{j=1}P(\boldsymbol{o}^T_{t+1}| q_t=i,q_{t+1}=j)P(q_t=i,q_{t+1}=j)}{P(q_t=i)}<br>\<br>= \sum^N_{j=1}P(\boldsymbol{o}^T_{t+1}|q_{t+1}=j)\frac{P(q_t=i,q_{t+1}=j)}{P(q_t=i)}<br>\<br>= \sum^N_{j=1} P(\boldsymbol{o}^T_{t+2}, \boldsymbol{o}<em>{t+1}|q</em>{t+1} = j)a_{ij}<br>\<br>=\sum^N_{j=1}P(\boldsymbol{o}^T_{t+2}|q_{t+1} = j)P(\boldsymbol{o}<em>{t+1}|q</em>{t+1} = j)a_{ij}<br>\<br>= \sum^N_{j=1}\beta_{t+1}(j)b_j(\boldsymbol{o}<em>{t+1})a</em>{ij}<br>$$</p>
<h2 id="3-EM算法及其在学习HMM参数中的应用"><a href="#3-EM算法及其在学习HMM参数中的应用" class="headerlink" title="3. EM算法及其在学习HMM参数中的应用"></a>3. EM算法及其在学习HMM参数中的应用</h2><h3 id="3-1-EM算法"><a href="#3-1-EM算法" class="headerlink" title="3.1 EM算法"></a>3.1 EM算法</h3><blockquote>
<p>期望最大算法（EM算法）是一种从不完全数据或有数据丢失的数据集（存在隐含变量）中求解概率模型参数的最大似然估计方法。</p>
</blockquote>
<p>假设我们有一组数据，我们希望计算出这组数据的分布概率，常见的有高斯分布。若这组数据仅属于一个高斯成分，那么我们可以直接计算均值和方差作为高斯分布的无偏估计；若这组数据属于多个高斯成分呢，显然无法计算均值和方差，因为我们不知道哪些数据属于高斯成分1，哪些数据属于高斯成分2…，这是由于隐变量产生了作用，在这个问题中隐变量就是数据属于哪个高斯成分，这个时候EM算法可以起作用了。</p>
<p>令$\boldsymbol{X}$表示已观测变量集，$\boldsymbol{Z}$表示隐变量集，$\Theta$表示模型参数。若欲对$\Theta$做极大似然估计，则应最大化对数似然</p>
<p>$$<br>LL(\Theta|\boldsymbol{X, Z}) = \ln P(\boldsymbol{X,Z}|\Theta)<br>$$</p>
<p>由于$\boldsymbol{Z}$是隐变量，上式无法直接求解。但此时可以通过对$\boldsymbol{Z}$计算期望，来最大化已观测数据的对数边际似然</p>
<p>$$<br>LL(\Theta|\boldsymbol{X}) = \ln P(\boldsymbol{X}|\Theta) = \ln \sum_{\boldsymbol{Z}}P(\boldsymbol{X,Z}|\Theta)<br>$$</p>
<p>EM算法的基本思想是：若参数$\Theta$已知，则根据训练数据推断出最优隐变量$\boldsymbol{Z}$的值（E步）；反之，若$\boldsymbol{Z}$的值已知，则可方便地对参数$\Theta$做极大似然估计（M步）。</p>
<p>于是，以初始值$\Theta^0$为起点（一般自行设置），迭代执行以下步骤直至收敛：</p>
<ul>
<li>基于$\Theta^t$推断隐变量$\boldsymbol{Z}$的期望，记为$\boldsymbol{Z}^t$；</li>
<li>基于已观测变量$\boldsymbol{X}$和$\boldsymbol{Z}^t$对参数$\Theta$做极大似然估计，记为$\Theta^{t+1}$。</li>
</ul>
<hr>
<p>更进一步，若我们不是取$\boldsymbol{Z}$的期望，而是基于$\Theta^t$计算隐变量$\boldsymbol{Z}$地概率分布$P(\boldsymbol{Z}|\boldsymbol{X},\Theta^t)$，则EM算法为：</p>
<ul>
<li>$\boldsymbol{E}$步：以当前参数$\Theta^t$推断隐变量分布$P(\boldsymbol{Z}|\boldsymbol{X},\Theta^t)$，并计算对数似然$LL(\Theta|\boldsymbol{X,Z})$关于$\boldsymbol{Z}$的期望，用$Q$表示</li>
</ul>
<p>$$<br>Q(\Theta|\Theta^t) = \mathbb{E}_{\boldsymbol{Z}|\boldsymbol{X},\Theta^t}LL(\Theta|\boldsymbol{X, Z})<br>$$</p>
<ul>
<li>$\boldsymbol{M}$步：寻找参数最大化期望似然</li>
</ul>
<p>$$<br>\Theta^{t+1} = \underset{\Theta}{\arg \max}Q(\Theta|\Theta^t)<br>$$</p>
<p>EM算法的特性：</p>
<ul>
<li>EM算法提供的是局部的似然度最优结果，因为仅在一轮的M步中更新参数；</li>
<li>对初始值敏感，初始值对最大似然度估计结果影响很大；</li>
<li>对完整数据集的选择需要根据实际情况来进行变更；</li>
<li>通常寻找一个针对期望值的近似表达式是困难的。</li>
</ul>
<h3 id="3-2-Baum-Welch算法"><a href="#3-2-Baum-Welch算法" class="headerlink" title="3.2 Baum-Welch算法"></a>3.2 Baum-Welch算法</h3><p>当隐变量符合马尔可夫链的形式时，EM算法可推导为Baum-Welch算法。下面的推导基于高斯分布HMM，完整数据包含了观测序列和隐马尔可夫链序列，例如$\boldsymbol{y} = [\boldsymbol{o}_1^T, \boldsymbol{q}_1^T]$，我们的目标是最大化观测序列概率$P(\boldsymbol{o}_1^T|\Theta)$（或者其似然值）。</p>
<p>E步中计算的期望，通过隐藏状态序列$\boldsymbol{q}_1^T$来确定，$\Theta，\Theta_0$分别表示当前以及前一轮EM迭代中的HMM参数：</p>
<p>$$<br>Q(\Theta|\Theta_0) = E[\log P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T|\Theta)|\boldsymbol{o}_1^T, \Theta_0]<br>$$</p>
<p>M步中通过最大化$Q(\Theta|\Theta_0)$来完成，这是为了取代直接取最大化$P(\boldsymbol{o}_1^T|\Theta)$，为什么可以取代，这是Baum不等式推导出的结果</p>
<p>$$<br>\log \frac{P(\boldsymbol{o}_1^T|\Theta)}{P(\boldsymbol{o}_1^T|\Theta_0)} \geqslant Q(\Theta|\Theta_0) - Q(\Theta_0|\Theta_0) \geqslant 0<br>$$</p>
<hr>
<p><strong>$\boldsymbol{E}$步骤</strong></p>
<p>目的简化条件期望值$Q(\Theta|\Theta_0)$，使其变成一个适合直接做最大化的形式。在已知前一轮的参数$\Theta_0$和观察序列$\boldsymbol{o}_1^T$的情况下，下面是基于状态序列$\boldsymbol{q}_1^T$的加权求和的期望值$Q(\Theta|\Theta_0)$</p>
<p>$$<br>Q(\Theta|\Theta_0) = E[\log P(\boldsymbol{o}<em>1^T, \boldsymbol{q}_1^T|\Theta)|\boldsymbol{o}_1^T, \Theta_0]<br>\<br>= \sum</em>{\boldsymbol{q}_1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0)\log P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T|\Theta)<br>$$</p>
<p>由于我们假定隐藏序列的状态$i$属于一个高斯成分（多元高斯分布），则其对数似然$N_t(i)$为</p>
<p>$$<br>N_t(i) = -\frac{D}{2}\log (2\pi) - \frac{1}{2}\log |\boldsymbol{\Sigma}_i|-\frac{1}{2}(\boldsymbol{o}_t-\boldsymbol{\mu}_i)^T\boldsymbol{\Sigma}_i^{-1}(\boldsymbol{o}_t-\boldsymbol{\mu}_i)<br>$$</p>
<p>由$P(\boldsymbol{q}<em>1^T) = \prod</em>{t=1}^{T-1}a_{q_tq_{t+1}}$和$P(\boldsymbol{o}_1^T, \boldsymbol{q}_1^T) = P(\boldsymbol{o}_1^T|\boldsymbol{q}_1^T)P(\boldsymbol{q}_1^T)$，所以</p>
<p>$$<br>\log P(\boldsymbol{o}<em>1^T, \boldsymbol{q}_1^T|\Theta) = \sum^T</em>{t=1}N_t(q_t) + \sum^{T-1}<em>{t=1}\log a</em>{q_tq_{t+1}}<br>$$</p>
<p>于是$Q(\Theta|\Theta_0)$重写为</p>
<p>$$<br>Q(\Theta|\Theta_0) = \sum_{\boldsymbol{q}<em>1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0)\sum^T</em>{t=1}N_t(q_t) + \sum_{\boldsymbol{q}<em>1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0)\sum^{T-1}</em>{t=1}\log a_{q_tq_{t+1}}<br>$$</p>
<p>其中第一部分可写为</p>
<p>$$<br>Q_1(\Theta|\Theta_0) = \sum^N_{i=1} { \sum_{\boldsymbol{q}<em>1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0)\sum^T</em>{t=1}N_t(q_t) } \delta_{q_t,i}<br>$$</p>
<p>第二部分</p>
<p>$$<br>Q_2(\Theta|\Theta_0) = \sum^N_{i=1}\sum^N_{j=1} { \sum_{\boldsymbol{q}<em>1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0)\sum^{T-1}</em>{t=1}\log a_{q_tq_{t+1}} } \delta_{q_t,i} \delta_{q_{t+1},j}<br>$$</p>
<p>$\delta_{q_t, i}$是克罗内克函数，当$q_t = i$取1，否则取0。</p>
<p>通过代换求和可以使用</p>
<p>$$<br>\sum_{\boldsymbol{q}<em>1^T}P(\boldsymbol{q}_1^T|\boldsymbol{o}_1^T, \Theta_0) \delta</em>{q_t,i} = P(q_t=i|\boldsymbol{o}_1^T,\Theta_0)<br>$$</p>
<p>通过上式简化$Q_1$和$Q_2$</p>
<p>$$<br>Q_1(\Theta|\Theta_0) =\sum^N_{i=1}\sum^T_{t=1}P(q_t=i|\boldsymbol{o}<em>1^T,\Theta_0)N_t(i)<br>\<br>Q_2(\Theta|\Theta_0) = \sum^N</em>{i=1}\sum^N_{j=1}\sum^{T-1}<em>{t=1} P(q_t=i,q</em>{t+1}=j|\boldsymbol{o}<em>1^T,\Theta_0)\log a</em>{ij}<br>$$</p>
<p>因为$Q_1(\Theta|\Theta_0)$只包含高斯参数，$Q_2(\Theta|\Theta_0)$只包含马尔科夫链参数，两个式子可以分别最大化。也就是说在最大化$Q(\Theta|\Theta_0)$时，公式中的权重，或者说$\gamma_t(i) = P(q_t=i|\boldsymbol{o}<em>1^T,\Theta_0)$和$\xi_t(i,j) = P(q_t=i,q</em>{t+1}=j|\boldsymbol{o}_1^T,\Theta_0)$，可以分别被认为是对方的已知常数。因此可以用前后向概率来计算。高斯HMM中的后验状态转移概率为</p>
<p>$$<br>\xi_t(i,j) = \frac{\alpha_t(i)\beta_{t+1}(j)a_{ij}\exp(N_{t+1}(j))}{P(\boldsymbol{o}<em>1^T|\Theta_0)}<br>\<br>t = 1,2,…,T-1<br>\<br>P(\boldsymbol{o}_1^T|\Theta_0) = \sum^N</em>{i=1}\sum^N_{j=1}\alpha_t(i)\beta_{t+1}(j)a_{ij}\exp(N_{t+1}(j))<br>$$</p>
<p>后验状态占用概率为</p>
<p>$$<br>\gamma_t(i) = \sum^N_{j=1}\xi_t(i,j)<br>\<br>t = 1,2,…,T-1<br>$$</p>
<p>$\gamma_T(i)$则可以通过它的特定定义得到：</p>
<p>$$<br>\gamma_T(i) = P(q_T=i|\boldsymbol{o}_1^T, \Theta_0) = \frac{P(q_T=i,\boldsymbol{o}_1^T| \Theta_0)}{P(\boldsymbol{o}_1^T| \Theta_0)} = \frac{\alpha_T(i)}{P(\boldsymbol{o}_1^T| \Theta_0)}<br>$$</p>
<p>对从左到右传播的HMM，在$i=N$时，$\gamma_T(i)$只有一个值1，其余值为0。因为我们将状态序列转换成了在状态$i$或状态对$(i,j)$上，因此得到了极大的简化。</p>
<p><strong>$\boldsymbol{M}$步骤</strong></p>
<p>高斯HMM马尔可夫链转移概率的重估公式通过令$\frac{\partial Q_2}{\partial a_{ij}} = 0$得到，对$Q_2$以及对$i,j=1,2,…,N$，使其服从$\sum^N_{j=1}a_{ij}=1$的约束条件。标准拉格朗日乘子法使重估公式变为</p>
<p>$$<br>\hat{a}<em>{ij} = \frac{\sum^{T-1}</em>{t=1}\xi_t(i,j)}{\sum^{T-1}_{t=1}\gamma_t(i)}<br>\<br>其中\xi_t(i,j)和\gamma_t(i)根据E步中公式计算<br>$$</p>
<p>$Q_1$的等价优化目标函数为</p>
<p>$$<br>Q_1(\boldsymbol{\mu}<em>i, \boldsymbol{\Sigma}_i) = \sum^N</em>{i=1}\sum^{T}_{t=1}\gamma_t(i)(\boldsymbol{o}_t-\boldsymbol{\mu}_i)^T\boldsymbol{\Sigma}_i^{-1}(\boldsymbol{o}_t-\boldsymbol{\mu}_i) - \frac{1}{2}\log |\boldsymbol{\Sigma}_i|<br>$$</p>
<p>所以协方差矩阵的重估公式通过令下式为0得到<br>$$<br>\frac{\partial Q_1}{\partial \boldsymbol{\Sigma}_i} = 0 \quad i = 1,2,…,N<br>$$</p>
<p>为了解上面的方程，令$\boldsymbol{K} = \boldsymbol{\Sigma}^{-1}$（为了简化，忽略状态角标$i$），之后将$Q_1$视为$\boldsymbol{K}$的一个方程。已知$\log|\boldsymbol{K}|$对$\boldsymbol{K}$的第$lm$项系数求导，其结果是方差矩阵$\boldsymbol{\Sigma}$的第$lm$项系数，即$\sigma_{lm}$，那么可以将$\frac{\partial Q_1}{\partial k_{lm}} = 0$化简为</p>
<p>$$<br>\sum^T_{t=1}\gamma_t(i){ \frac{1}{2}\sigma_{lm} - \frac{1}{2}(\boldsymbol{o}_t-\boldsymbol{\mu}_i)_l(\boldsymbol{o}_t-\boldsymbol{\mu}_i)_m } = 0<br>\<br>l,m = 1,2,…,D<br>$$</p>
<p>将上式写成矩阵形式</p>
<p>$$<br>\hat{\boldsymbol{\Sigma}}<em>i = \frac{\sum^T</em>{t=1}\gamma_t(i)(\boldsymbol{o}<em>t - \hat{\boldsymbol{\mu}}_i)(\boldsymbol{o}_t - \hat{\boldsymbol{\mu}}_i)^T}{\sum^T</em>{t=1}\gamma_t(i)}<br>\<br>i=1,2,…,N<br>$$</p>
<p>其中高斯HMM均值向量$\hat{\boldsymbol{\mu}}_i$的重估公式为</p>
<p>$$<br>\hat{\boldsymbol{\mu}}<em>i = \frac{\sum^T</em>{t=1}\gamma_t(i)\boldsymbol{o}<em>t}{\sum^T</em>{t=1}\gamma_t(i)}<br>$$</p>
<p>上面的推导针对单高斯HMM的情况。针对GMM-HMM的EM算法，通常认为每一帧中每一状态上的高斯成分是一个隐变量。</p>
<h2 id="4-用于解码HMM状态序列的维特比算法"><a href="#4-用于解码HMM状态序列的维特比算法" class="headerlink" title="4. 用于解码HMM状态序列的维特比算法"></a>4. 用于解码HMM状态序列的维特比算法</h2><blockquote>
<p>在关于数个阶段之间互不关联的优化问题中，不管初始状态或者初始决策是什么，剩余的决策应该包含一个最优的方法用于选择从第一个选择得到的状态中去得到剩余的决策。</p>
</blockquote>
<p>马尔可夫决策过程由两部分参数决定，第一部分是转移概率</p>
<p>$$<br>P^k_{ij}(n) = P(state_j,stage_{n+1}|state_i,stage_n,decision_k)<br>$$</p>
<p>其中，系统的当前状态只依赖于系统的前一阶段所处的状态以及在那个状态上所采取的决策。第二部分参数提供了决策收益</p>
<p>$$<br>R^k_i(n) = 在n阶段和状态i上，采用决策k时得到的收益<br>$$</p>
<p>下面定义$F(n,i)$作为阶段$n$和状态$i$上最优决策被采取时的平均总收益：</p>
<p>$$<br>F(n,i) = \underset{k}{\max}{ R^k_i(n)+\sum_j P^k_{ij}(n)F(n+1,i) }<br>$$</p>
<p>特别地，当$n=N$（最后阶段），状态$i$的总收益</p>
<p>$$<br>F(N,i) = \underset{k}{\max} R^k_i(n)<br>$$</p>
<p>最优决策序列可以在最后一轮递归计算之后进行回溯。</p>
<hr>
<p>在给定一组观察序列$\boldsymbol{o}^T_1 = \boldsymbol{o}_1,\boldsymbol{o}_2,…,\boldsymbol{o}_T$的情况下，如何高效地找到最优地HMM状态序列。</p>
<p>对一个状态转移概率$a_{ij}$给定地HMM，设状态输出概率分布为$b_i(\boldsymbol{o}_t)$，令$\delta_i(t)$表示部分观察序列$\boldsymbol{o}_1^t$到达时间$t$，同时相应地HMM状态序列在该事件处在状态$i$时地联合似然度的最大值：</p>
<p>$$<br>\delta_i(t) = \underset{q_1,q_2,…,q_{t-1}}{\max} P(\boldsymbol{o}^t_1,q_1^{t-1},q_t=i)<br>$$</p>
<p>在最终阶段$t=T$时，我们有最优函数$\delta_i(T)$，这个可以通过递归计算得到</p>
<p>$$<br>\delta_j(t+1) = \underset{i}{\max} \delta_i(t)a_{ij}b_j(\boldsymbol{o}_{t+1})<br>$$</p>
<p>完整的维特比算法要求递归初始化、递归终止条件和路线回溯。结果包含最大联合似然度观察和状态序列$P^<em>$，以及相应地状态转移路径$q^</em>(t)$。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">推荐文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/7d1dcda7.html" rel="bookmark">模型评估与选择</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/280b588e.html" rel="bookmark">支持向量机</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/8ddc7426.html" rel="bookmark">决策树</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/4b26bf35.html" rel="bookmark">语音识别-MFCC</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/24da735a.html" rel="bookmark">语音识别-GMM</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Tao Zhou
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zhoutao822.coding.me/archives/2f863467.html" title="语音识别-HMM">http://zhoutao822.coding.me/archives/2f863467.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Theory/" rel="tag"># Theory</a>
              <a href="/tags/HMM/" rel="tag"># HMM</a>
              <a href="/tags/EM-Algorithm/" rel="tag"># EM Algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/4b26bf35.html" rel="prev" title="语音识别-MFCC">
      <i class="fa fa-chevron-left"></i> 语音识别-MFCC
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/2d6320ff.html" rel="next" title="神经网络-coding">
      神经网络-coding <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-马尔可夫链"><span class="nav-text">1. 马尔可夫链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-序列与模型"><span class="nav-text">2. 序列与模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-隐马尔可夫模型的性质"><span class="nav-text">2.1 隐马尔可夫模型的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-隐马尔可夫模型似然度的计算"><span class="nav-text">2.2 隐马尔可夫模型似然度的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-计算似然度"><span class="nav-text">2.3 计算似然度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-EM算法及其在学习HMM参数中的应用"><span class="nav-text">3. EM算法及其在学习HMM参数中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-EM算法"><span class="nav-text">3.1 EM算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Baum-Welch算法"><span class="nav-text">3.2 Baum-Welch算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-用于解码HMM状态序列的维特比算法"><span class="nav-text">4. 用于解码HMM状态序列的维特比算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tao Zhou"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Tao Zhou</p>
  <div class="site-description" itemprop="description">学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tao Zhou</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">897k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:36</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
              leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz',
            'X-LC-Key': 'xoukWFyqvFIXJ6DfxLLYtsTP',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'iyNzyQRx6yCU5YQVEXPl0hSe-gzGzoHsz',
      appKey: 'xoukWFyqvFIXJ6DfxLLYtsTP',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
